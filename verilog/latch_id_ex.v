// File: latch_id_ex.v
// Generated by MyHDL 0.7
// Date: Sat Dec 22 14:17:07 2012


module latch_id_ex (
    clk,
    rst,
    pc_adder_in,
    data1_in,
    data2_in,
    address32_in,
    jumpaddr_in,
    rs_in,
    rt_in,
    rd_in,
    shamt_in,
    func_in,
    RegDst_in,
    ALUop_in,
    ALUSrc_in,
    Branch_in,
    Jump_in,
    MemRead_in,
    MemWrite_in,
    RegWrite_in,
    MemtoReg_in,
    pc_adder_out,
    data1_out,
    data2_out,
    address32_out,
    branch_addr32_out,
    jumpaddr_out,
    rs_out,
    rt_out,
    rd_out,
    shamt_out,
    func_out,
    RegDst_out,
    ALUop_out,
    ALUSrc_out,
    Branch_out,
    Jump_out,
    MemRead_out,
    MemWrite_out,
    RegWrite_out,
    MemtoReg_out
);
// Latch to control state between Instruction Decoding and Execution

input [0:0] clk;
input [0:0] rst;
input signed [31:0] pc_adder_in;
input signed [31:0] data1_in;
input signed [31:0] data2_in;
input signed [31:0] address32_in;
input signed [25:0] jumpaddr_in;
input [4:0] rs_in;
input [4:0] rt_in;
input [4:0] rd_in;
input [4:0] shamt_in;
input [5:0] func_in;
input [0:0] RegDst_in;
input [4:0] ALUop_in;
input [0:0] ALUSrc_in;
input [0:0] Branch_in;
input [0:0] Jump_in;
input [1:0] MemRead_in;
input [1:0] MemWrite_in;
input [0:0] RegWrite_in;
input [0:0] MemtoReg_in;
output signed [31:0] pc_adder_out;
reg signed [31:0] pc_adder_out;
output signed [31:0] data1_out;
reg signed [31:0] data1_out;
output signed [31:0] data2_out;
reg signed [31:0] data2_out;
output signed [31:0] address32_out;
reg signed [31:0] address32_out;
output signed [31:0] branch_addr32_out;
reg signed [31:0] branch_addr32_out;
output signed [31:0] jumpaddr_out;
reg signed [31:0] jumpaddr_out;
output [4:0] rs_out;
reg [4:0] rs_out;
output [4:0] rt_out;
reg [4:0] rt_out;
output [4:0] rd_out;
reg [4:0] rd_out;
output [4:0] shamt_out;
reg [4:0] shamt_out;
output [5:0] func_out;
reg [5:0] func_out;
output [0:0] RegDst_out;
reg [0:0] RegDst_out;
output [4:0] ALUop_out;
reg [4:0] ALUop_out;
output [0:0] ALUSrc_out;
reg [0:0] ALUSrc_out;
output [0:0] Branch_out;
reg [0:0] Branch_out;
output [0:0] Jump_out;
reg [0:0] Jump_out;
output [1:0] MemRead_out;
reg [1:0] MemRead_out;
output [1:0] MemWrite_out;
reg [1:0] MemWrite_out;
output [0:0] RegWrite_out;
reg [0:0] RegWrite_out;
output [0:0] MemtoReg_out;
reg [0:0] MemtoReg_out;

always @(posedge clk) begin: LATCH_ID_EX_LATCH
    if (rst == 1) begin
        pc_adder_out <= 0;
        data1_out <= 0;
        data2_out <= 0;
        address32_out <= 0; 
        branch_addr32_out <= 0;
        jumpaddr_out <= 0;
        rs_out <= 0; 
        rt_out <= 0;
        rd_out <= 0;
        shamt_out <= 0;
        func_out <= 0;
        RegDst_out <= 0;
        ALUop_out <= 0;
        ALUSrc_out <= 0;
        Branch_out <= 0;
        Jump_out <= 0;
        MemRead_out <= 0;
        MemWrite_out <=  0;
        RegWrite_out <= 0;
        MemtoReg_out <= 0; 
    end
    else begin
        pc_adder_out <= pc_adder_in;
        data1_out <= data1_in;
        data2_out <= data2_in;
        address32_out <= address32_in;
        branch_addr32_out <= {address32_in[29:0], 2'h0};
        jumpaddr_out <= {6'h0, jumpaddr_in};
        rs_out <= rs_in;
        rt_out <= rt_in;
        rd_out <= rd_in;
        shamt_out <= shamt_in;
        func_out <= func_in;
        RegDst_out <= RegDst_in;
        ALUop_out <= ALUop_in;
        ALUSrc_out <= ALUSrc_in;
        Branch_out <= Branch_in;
        Jump_out <= Jump_in;
        MemRead_out <= MemRead_in;
        MemWrite_out <= MemWrite_in;
        RegWrite_out <= RegWrite_in;
        MemtoReg_out <= MemtoReg_in;
    end
end

endmodule
