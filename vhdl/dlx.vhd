-- File: dlx.vhd
-- Generated by MyHDL 0.6
-- Date: Sat Nov 20 01:41:41 2010

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_06.all;

entity dlx is
end entity dlx;

architecture MyHDL of dlx is

signal PcAdderOut_ex: unsigned(31 downto 0);
signal BranchAdderO_mem: signed (31 downto 0);
signal RegWrite_ex: unsigned(0 downto 0);
signal Func_ex: unsigned(5 downto 0);
signal MemRead_id: unsigned(0 downto 0);
signal RegWrite_id: unsigned(0 downto 0);
signal Rd_id: unsigned(4 downto 0);
signal MuxAluDataSrc_ex: signed (31 downto 0);
signal NextIp: unsigned(31 downto 0);
signal RegDst_id: unsigned(0 downto 0);
signal MemtoReg_wb: unsigned(0 downto 0);
signal Data1_id: signed (31 downto 0);
signal MemWrite_mem: unsigned(0 downto 0);
signal Data2_mem: signed (31 downto 0);
signal Address32_ex: signed (31 downto 0);
signal Opcode_id: unsigned(5 downto 0);
signal Address16_id: signed (15 downto 0);
signal Clk: unsigned(0 downto 0);
signal WrRegDest_ex: unsigned(31 downto 0);
signal Address32_id: signed (31 downto 0);
signal NopSignal: unsigned(0 downto 0);
signal ALUSrc_ex: unsigned(0 downto 0);
signal Zero_mem: unsigned(0 downto 0);
signal AluControl: unsigned(3 downto 0);
signal ForwMux2Out: signed (31 downto 0);
signal RegDst_ex: unsigned(0 downto 0);
signal ForwardA: unsigned(1 downto 0);
signal Rs_id: unsigned(4 downto 0);
signal Rt_id: unsigned(4 downto 0);
signal ALUop_ex: unsigned(1 downto 0);
signal AluResult_mem: signed (31 downto 0);
signal Data2_ex: signed (31 downto 0);
signal ALUSrc_id: unsigned(0 downto 0);
signal Instruction_if: unsigned(31 downto 0);
signal Func_id: unsigned(5 downto 0);
signal DataMemOut_wb: signed (31 downto 0);
signal Zero_ex: unsigned(0 downto 0);
signal AluResult_wb: signed (31 downto 0);
signal ForwMux1Out: signed (31 downto 0);
signal MemRead_ex: unsigned(0 downto 0);
signal MuxMemO_wb: signed (31 downto 0);
signal Reset: unsigned(0 downto 0);
signal Branch_id: unsigned(0 downto 0);
signal Rs_ex: unsigned(4 downto 0);
signal MemWrite_id: unsigned(0 downto 0);
signal Instruction_id: unsigned(31 downto 0);
signal Shamt_id: unsigned(4 downto 0);
signal Branch_ex: unsigned(0 downto 0);
signal MemtoReg_id: unsigned(0 downto 0);
signal FlushOnBranch: unsigned(0 downto 0);
signal RegWrite_wb: unsigned(0 downto 0);
signal Stall: unsigned(0 downto 0);
signal WrRegDest_mem: unsigned(31 downto 0);
signal RegWrite_mem: unsigned(0 downto 0);
signal MemRead_mem: unsigned(0 downto 0);
signal ForwardB: unsigned(1 downto 0);
signal AluResult_ex: signed (31 downto 0);
signal MemtoReg_ex: unsigned(0 downto 0);
signal Branch_mem: unsigned(0 downto 0);
signal Ip: unsigned(31 downto 0);
signal PcAdderOut_if: unsigned(31 downto 0);
signal Rd_ex: unsigned(4 downto 0);
signal BranchAdderO_ex: signed (31 downto 0);
signal Data2_id: signed (31 downto 0);
signal PcAdderOut_id: unsigned(31 downto 0);
signal ClkPc: unsigned(0 downto 0);
signal ALUop_id: unsigned(1 downto 0);
signal Rt_ex: unsigned(4 downto 0);
signal MemtoReg_mem: unsigned(0 downto 0);
signal DataMemOut_mem: signed (31 downto 0);
signal Data1_ex: signed (31 downto 0);
signal MemWrite_ex: unsigned(0 downto 0);
signal WrRegDest_wb: unsigned(31 downto 0);
signal branch_adder__control: unsigned(3 downto 0);
signal branch_adder__zero: unsigned(0 downto 0);
signal forw_mux2__chan4: unsigned(0 downto 0);
signal mux_pc_source_chan2: unsigned(31 downto 0);
signal pc_adder_control: unsigned(3 downto 0);
signal pc_adder_zero: unsigned(0 downto 0);
signal pc_adder_op2: unsigned(31 downto 0);
type t_array_data_memory__mem is array(0 to 1024-1) of signed (31 downto 0);
signal data_memory__mem: t_array_data_memory__mem;
type t_array_register_file_i_mem is array(0 to 32-1) of signed (31 downto 0);
signal register_file_i_mem: t_array_register_file_i_mem;

begin

Reset <= to_unsigned(0, 1);
branch_adder__control <= to_unsigned(2, 4);
forw_mux2__chan4 <= to_unsigned(0, 1);
mux_pc_source_chan2 <= to_unsigned(0, 32);
pc_adder_control <= to_unsigned(2, 4);
pc_adder_op2 <= to_unsigned(1, 32);

DLX_CONTROL__LOGIC: process (NopSignal, Stall, Opcode_id) is
begin
    if ((NopSignal = 1) or (Stall = 1)) then
        RegDst_id <= "0";
        ALUSrc_id <= "0";
        MemtoReg_id <= "0";
        RegWrite_id <= "0";
        MemRead_id <= "0";
        MemWrite_id <= "0";
        Branch_id <= "0";
        ALUop_id <= to_unsigned(string'("00"), 2);
    else
        if (Opcode_id = 0) then
            RegDst_id <= "1";
            ALUSrc_id <= "0";
            MemtoReg_id <= "0";
            RegWrite_id <= "1";
            MemRead_id <= "0";
            MemWrite_id <= "0";
            Branch_id <= "0";
            ALUop_id <= to_unsigned(string'("10"), 2);
        elsif (Opcode_id = 35) then
            RegDst_id <= "0";
            ALUSrc_id <= "1";
            MemtoReg_id <= "1";
            RegWrite_id <= "1";
            MemRead_id <= "1";
            MemWrite_id <= "0";
            Branch_id <= "0";
            ALUop_id <= to_unsigned(string'("00"), 2);
        elsif (Opcode_id = 43) then
            ALUSrc_id <= "1";
            RegWrite_id <= "0";
            MemRead_id <= "0";
            MemWrite_id <= "1";
            Branch_id <= "0";
            ALUop_id <= to_unsigned(string'("00"), 2);
        elsif (Opcode_id = 4) then
            ALUSrc_id <= "0";
            RegWrite_id <= "0";
            MemRead_id <= "0";
            MemWrite_id <= "0";
            Branch_id <= "1";
            ALUop_id <= to_unsigned(string'("01"), 2);
        end if;
    end if;
end process DLX_CONTROL__LOGIC;

DLX_CLK_DRIVER_DRIVE_CLOCK: process (<myhdl._delay.delay object at 0x9294c8c>) is
begin
    Clk <= (not to_boolean(Clk));
end process DLX_CLK_DRIVER_DRIVE_CLOCK;

DLX_ALU__LOGIC_ALU: process (AluControl, ForwMux1Out, MuxAluDataSrc_ex) is
begin
    if (AluControl = 0) then
        null;
    elsif (AluControl = 1) then
        null;
    elsif (AluControl = 2) then
        AluResult_ex <= (ForwMux1Out + MuxAluDataSrc_ex);
    elsif (AluControl = 6) then
        AluResult_ex <= (ForwMux1Out - MuxAluDataSrc_ex);
    elsif (AluControl = 7) then
        if (ForwMux1Out < MuxAluDataSrc_ex) then
            AluResult_ex <= "00000000000000000000000000000001";
        else
            AluResult_ex <= "00000000000000000000000000000000";
        end if;
    elsif (AluControl = 12) then
        null;
    end if;
end process DLX_ALU__LOGIC_ALU;

DLX_ALU__ZERO_DETECTOR: process (AluResult_ex) is
begin
    if (AluResult_ex = 0) then
        Zero_ex <= "1";
    else
        Zero_ex <= "0";
    end if;
end process DLX_ALU__ZERO_DETECTOR;

DLX_BRANCH_ADDER__LOGIC_ALU: process (branch_adder__control, PcAdderOut_ex, Address32_ex) is
begin
    if (branch_adder__control = 0) then
        null;
    elsif (branch_adder__control = 1) then
        null;
    elsif (branch_adder__control = 2) then
        BranchAdderO_ex <= resize(signed(resize(PcAdderOut_ex, 33)) + Address32_ex, 32);
    elsif (branch_adder__control = 6) then
        BranchAdderO_ex <= resize(signed(resize(PcAdderOut_ex, 33)) - Address32_ex, 32);
    elsif (branch_adder__control = 7) then
        if (signed(resize(PcAdderOut_ex, 33)) < Address32_ex) then
            BranchAdderO_ex <= "00000000000000000000000000000001";
        else
            BranchAdderO_ex <= "00000000000000000000000000000000";
        end if;
    elsif (branch_adder__control = 12) then
        null;
    end if;
end process DLX_BRANCH_ADDER__LOGIC_ALU;

DLX_BRANCH_ADDER__ZERO_DETECTOR: process (BranchAdderO_ex) is
begin
    if (BranchAdderO_ex = 0) then
        branch_adder__zero <= "1";
    else
        branch_adder__zero <= "0";
    end if;
end process DLX_BRANCH_ADDER__ZERO_DETECTOR;

DLX_LATCH_MEM_WB__LATCH: process (Clk, Reset) is
begin
    if (Reset = 1) then
        DataMemOut_wb <= "00000000000000000000000000000000";
        AluResult_wb <= "00000000000000000000000000000000";
        WrRegDest_wb <= "00000000000000000000000000000000";
        RegWrite_wb <= "0";
        MemtoReg_wb <= "0";
    elsif rising_edge(Clk) then
        DataMemOut_wb <= DataMemOut_mem;
        AluResult_wb <= AluResult_mem;
        WrRegDest_wb <= WrRegDest_mem;
        RegWrite_wb <= RegWrite_mem;
        MemtoReg_wb <= MemtoReg_mem;
    end if;
end process DLX_LATCH_MEM_WB__LATCH;

DLX_LATCH_IF_ID__LATCH: process (Clk, FlushOnBranch) is
begin
    if (FlushOnBranch = 1) then
        Instruction_id <= "00000000000000000000000000000000";
        PcAdderOut_id <= "00000000000000000000000000000000";
    elsif rising_edge(Clk) then
        if (not to_boolean(Stall)) then
            Instruction_id <= Instruction_if;
            PcAdderOut_id <= PcAdderOut_if;
        end if;
    end if;
end process DLX_LATCH_IF_ID__LATCH;

DLX_LATCH_EX_MEM__LATCH: process (Clk, Reset) is
begin
    if (Reset = 1) then
        BranchAdderO_mem <= "00000000000000000000000000000000";
        AluResult_mem <= "00000000000000000000000000000000";
        Zero_mem <= "0";
        Data2_mem <= "00000000000000000000000000000000";
        WrRegDest_mem <= "00000000000000000000000000000000";
        Branch_mem <= "0";
        MemRead_mem <= "0";
        MemWrite_mem <= "0";
        RegWrite_mem <= "0";
        MemtoReg_mem <= "0";
    elsif rising_edge(Clk) then
        BranchAdderO_mem <= BranchAdderO_ex;
        AluResult_mem <= AluResult_ex;
        Zero_mem <= Zero_ex;
        Data2_mem <= Data2_ex;
        WrRegDest_mem <= WrRegDest_ex;
        Branch_mem <= Branch_ex;
        MemRead_mem <= MemRead_ex;
        MemWrite_mem <= MemWrite_ex;
        RegWrite_mem <= RegWrite_ex;
        MemtoReg_mem <= MemtoReg_ex;
    end if;
end process DLX_LATCH_EX_MEM__LATCH;


Address32_id <= resize(Address16_id, 32);

DLX_FORWARDING__HAZARDS_CONTROL: process (Rs_ex, WrRegDest_wb, RegWrite_wb, RegWrite_mem, Rt_ex, WrRegDest_mem) is
begin
    if ((RegWrite_mem = 1) and (WrRegDest_mem /= 0) and (WrRegDest_mem = Rs_ex)) then
        ForwardA <= "10";
    elsif ((RegWrite_wb = 1) and (WrRegDest_wb /= 0) and (WrRegDest_mem /= Rs_ex) and (WrRegDest_wb = Rs_ex)) then
        ForwardA <= "01";
    else
        ForwardA <= "00";
    end if;
    if ((RegWrite_mem = 1) and (WrRegDest_mem /= 0) and (WrRegDest_mem = Rt_ex)) then
        ForwardB <= "10";
    elsif ((RegWrite_wb = 1) and (WrRegDest_wb /= 0) and (WrRegDest_mem /= Rt_ex) and (WrRegDest_wb = Rt_ex)) then
        ForwardB <= "01";
    else
        ForwardB <= "00";
    end if;
end process DLX_FORWARDING__HAZARDS_CONTROL;

DLX_PC_ADDER_LOGIC_ALU: process (pc_adder_control, Ip, pc_adder_op2) is
begin
    if (pc_adder_control = 0) then
        null;
    elsif (pc_adder_control = 1) then
        null;
    elsif (pc_adder_control = 2) then
        PcAdderOut_if <= (Ip + pc_adder_op2);
    elsif (pc_adder_control = 6) then
        PcAdderOut_if <= (Ip - pc_adder_op2);
    elsif (pc_adder_control = 7) then
        if (Ip < pc_adder_op2) then
            PcAdderOut_if <= "00000000000000000000000000000001";
        else
            PcAdderOut_if <= "00000000000000000000000000000000";
        end if;
    elsif (pc_adder_control = 12) then
        null;
    end if;
end process DLX_PC_ADDER_LOGIC_ALU;

DLX_PC_ADDER_ZERO_DETECTOR: process (PcAdderOut_if) is
begin
    if (PcAdderOut_if = 0) then
        pc_adder_zero <= "1";
    else
        pc_adder_zero <= "0";
    end if;
end process DLX_PC_ADDER_ZERO_DETECTOR;

DLX_HAZARD_DETECTOR__LOGIC: process (Rt_id, Rs_id, Rt_ex, MemRead_ex) is
begin
    if ((MemRead_ex = 1) and ((Rt_ex = Rs_id) or (Rt_ex = Rt_id))) then
        Stall <= "1";
    else
        Stall <= "0";
    end if;
end process DLX_HAZARD_DETECTOR__LOGIC;

DLX_REGISTER_FILE_I_LOGIC: process (Clk) is
begin
    if falling_edge(Clk) then
        if (RegWrite_wb = 1) then
            register_file_i_mem(to_integer(WrRegDest_wb)) <= MuxMemO_wb;
        end if;
        Data1_id <= register_file_i_mem(to_integer(Rs_id));
        Data2_id <= register_file_i_mem(to_integer(Rt_id));
    end if;
end process DLX_REGISTER_FILE_I_LOGIC;

DLX_MUX_WREG_ROUTE_CHANNEL: process (RegDst_ex, Rt_ex, Rd_ex) is
begin
    if (RegDst_ex = 0) then
        WrRegDest_ex <= resize(Rt_ex, 32);
    else
        WrRegDest_ex <= resize(Rd_ex, 32);
    end if;
end process DLX_MUX_WREG_ROUTE_CHANNEL;

DLX_MUX_PC_SOURCE_ROUTE_CHANNEL: process (FlushOnBranch, PcAdderOut_if, mux_pc_source_chan2) is
begin
    if (FlushOnBranch = 0) then
        NextIp <= PcAdderOut_if;
    else
        NextIp <= mux_pc_source_chan2;
    end if;
end process DLX_MUX_PC_SOURCE_ROUTE_CHANNEL;

DLX_CLK_DRIVER_PC_DRIVE_CLOCK: process (<myhdl._delay.delay object at 0x9294cec>) is
begin
    ClkPc <= (not to_boolean(ClkPc));
end process DLX_CLK_DRIVER_PC_DRIVE_CLOCK;

DLX_DATA_MEMORY__LOGIC: process (Clk) is
begin
    if falling_edge(Clk) then
        if (MemWrite_mem = 1) then
            data_memory__mem(to_integer(AluResult_mem)) <= Data2_mem;
        elsif (MemRead_mem = 1) then
            DataMemOut_mem <= data_memory__mem(to_integer(AluResult_mem));
        end if;
    end if;
end process DLX_DATA_MEMORY__LOGIC;

DLX_PC_UPDATE: process (Clk) is
begin
    if falling_edge(Clk) then
        if (not to_boolean(Stall)) then
            Ip <= NextIp;
        end if;
    end if;
end process DLX_PC_UPDATE;

DLX_FORW_MUX1__ROUTE_CHANNEL: process (forw_mux2__chan4, ForwardA, Data1_ex, AluResult_mem, MuxMemO_wb) is
begin
    if (ForwardA = 0) then
        ForwMux1Out <= Data1_ex;
    elsif (ForwardA = 1) then
        ForwMux1Out <= MuxMemO_wb;
    elsif (ForwardA = 2) then
        ForwMux1Out <= AluResult_mem;
    elsif (ForwardA = 3) then
        ForwMux1Out <= signed(resize(forw_mux2__chan4, 32));
    end if;
end process DLX_FORW_MUX1__ROUTE_CHANNEL;

DLX_INSTRUCTION_DECODER__DECODE: process (Instruction_id) is
begin
    Opcode_id <= Instruction_id(32-1 downto 26);
    Rs_id <= Instruction_id(26-1 downto 21);
    Rt_id <= Instruction_id(21-1 downto 16);
    Rd_id <= Instruction_id(16-1 downto 11);
    Shamt_id <= Instruction_id(11-1 downto 6);
    Func_id <= Instruction_id(6-1 downto 0);
    Address16_id <= signed(Instruction_id(16-1 downto 0));
    if (Instruction_id = 0) then
        NopSignal <= "1";
    else
        NopSignal <= "0";
    end if;
end process DLX_INSTRUCTION_DECODER__DECODE;


FlushOnBranch <= (Branch_mem and Zero_mem);

DLX_MUX_MEM2REG__ROUTE_CHANNEL: process (MemtoReg_wb, AluResult_wb, DataMemOut_wb) is
begin
    if (MemtoReg_wb = 0) then
        MuxMemO_wb <= AluResult_wb;
    else
        MuxMemO_wb <= DataMemOut_wb;
    end if;
end process DLX_MUX_MEM2REG__ROUTE_CHANNEL;

DLX_LATCH_ID_EX__LATCH: process (Clk, FlushOnBranch) is
begin
    if (FlushOnBranch = 1) then
        PcAdderOut_ex <= "00000000000000000000000000000000";
        Data1_ex <= "00000000000000000000000000000000";
        Data2_ex <= "00000000000000000000000000000000";
        Address32_ex <= "00000000000000000000000000000000";
        Rt_ex <= "00000";
        Rs_ex <= "00000";
        Rd_ex <= "00000";
        Func_ex <= "000000";
        RegDst_ex <= "0";
        ALUop_ex <= "00";
        ALUSrc_ex <= "0";
        Branch_ex <= "0";
        MemRead_ex <= "0";
        MemWrite_ex <= "0";
        RegWrite_ex <= "0";
        MemtoReg_ex <= "0";
    elsif rising_edge(Clk) then
        PcAdderOut_ex <= PcAdderOut_id;
        Data1_ex <= Data1_id;
        Data2_ex <= Data2_id;
        Address32_ex <= Address32_id;
        Rs_ex <= Rs_id;
        Rt_ex <= Rt_id;
        Rd_ex <= Rd_id;
        Func_ex <= Func_id;
        RegDst_ex <= RegDst_id;
        ALUop_ex <= ALUop_id;
        ALUSrc_ex <= ALUSrc_id;
        Branch_ex <= Branch_id;
        MemRead_ex <= MemRead_id;
        MemWrite_ex <= MemWrite_id;
        RegWrite_ex <= RegWrite_id;
        MemtoReg_ex <= MemtoReg_id;
    end if;
end process DLX_LATCH_ID_EX__LATCH;

DLX_ALU_CONTROL__LOGIC: process (ALUop_ex, Func_ex) is
begin
    if ((not to_boolean(ALUop_ex(0))) and (not to_boolean(ALUop_ex(1)))) then
        AluControl <= to_unsigned(string'("0010"), 4);
    elsif to_boolean(ALUop_ex(0)) then
        AluControl <= to_unsigned(string'("0110"), 4);
    elsif to_boolean(ALUop_ex(1)) then
        if (bin(Func_ex(3-1 downto 0), 4) = string'("0000")) then
            AluControl <= to_unsigned(string'("0010"), 4);
        elsif (bin(Func_ex(3-1 downto 0), 4) = string'("0010")) then
            AluControl <= to_unsigned(string'("0110"), 4);
        elsif (bin(Func_ex(3-1 downto 0), 4) = string'("0100")) then
            AluControl <= to_unsigned(string'("0000"), 4);
        elsif (bin(Func_ex(3-1 downto 0), 4) = string'("0101")) then
            AluControl <= to_unsigned(string'("0001"), 4);
        elsif (bin(Func_ex(3-1 downto 0), 4) = string'("1010")) then
            AluControl <= to_unsigned(string'("0111"), 4);
        else
            AluControl <= to_unsigned(0, 4);
        end if;
    end if;
end process DLX_ALU_CONTROL__LOGIC;

DLX_IM_LOGIC: process (Ip) is
begin
    case to_integer(Ip) is
        when 0 => Instruction_if <= "00000000001000100000000000100000";
        when 1 => Instruction_if <= "00010000100001001111111111111111";
        when 2 => Instruction_if <= "00000000010000110000100000100000";
        when 3 => Instruction_if <= "00000000001001000010100000100010";
        when 4 => Instruction_if <= "00000000000000000000000000000000";
        when 5 => Instruction_if <= "00000000000000000000000000000000";
        when 6 => Instruction_if <= "00000000000000000000000000000000";
        when 7 => Instruction_if <= "00000000000000000000000000000000";
        when 8 => Instruction_if <= "00000000000000000000000000000000";
        when 9 => Instruction_if <= "00000000000000000000000000000000";
        when 10 => Instruction_if <= "00000000000000000000000000000000";
        when 11 => Instruction_if <= "00000000000000000000000000000000";
        when 12 => Instruction_if <= "00000000000000000000000000000000";
        when 13 => Instruction_if <= "00000000000000000000000000000000";
        when 14 => Instruction_if <= "00000000000000000000000000000000";
        when 15 => Instruction_if <= "00000000000000000000000000000000";
        when 16 => Instruction_if <= "00000000000000000000000000000000";
        when 17 => Instruction_if <= "00000000000000000000000000000000";
        when 18 => Instruction_if <= "00000000000000000000000000000000";
        when 19 => Instruction_if <= "00000000000000000000000000000000";
        when 20 => Instruction_if <= "00000000000000000000000000000000";
        when 21 => Instruction_if <= "00000000000000000000000000000000";
        when 22 => Instruction_if <= "00000000000000000000000000000000";
        when 23 => Instruction_if <= "00000000000000000000000000000000";
        when 24 => Instruction_if <= "00000000000000000000000000000000";
        when 25 => Instruction_if <= "00000000000000000000000000000000";
        when 26 => Instruction_if <= "00000000000000000000000000000000";
        when 27 => Instruction_if <= "00000000000000000000000000000000";
        when 28 => Instruction_if <= "00000000000000000000000000000000";
        when 29 => Instruction_if <= "00000000000000000000000000000000";
        when 30 => Instruction_if <= "00000000000000000000000000000000";
        when others => Instruction_if <= "00000000000000000000000000000000";
    end case;
end process DLX_IM_LOGIC;

DLX_FORW_MUX2__ROUTE_CHANNEL: process (forw_mux2__chan4, ForwardB, Data2_ex, AluResult_mem, MuxMemO_wb) is
begin
    if (ForwardB = 0) then
        ForwMux2Out <= Data2_ex;
    elsif (ForwardB = 1) then
        ForwMux2Out <= MuxMemO_wb;
    elsif (ForwardB = 2) then
        ForwMux2Out <= AluResult_mem;
    elsif (ForwardB = 3) then
        ForwMux2Out <= signed(resize(forw_mux2__chan4, 32));
    end if;
end process DLX_FORW_MUX2__ROUTE_CHANNEL;

DLX_MUX_ALU_SRC_ROUTE_CHANNEL: process (ALUSrc_ex, ForwMux2Out, Address32_ex) is
begin
    if (ALUSrc_ex = 0) then
        MuxAluDataSrc_ex <= ForwMux2Out;
    else
        MuxAluDataSrc_ex <= Address32_ex;
    end if;
end process DLX_MUX_ALU_SRC_ROUTE_CHANNEL;

end architecture MyHDL;
