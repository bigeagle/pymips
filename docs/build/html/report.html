

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introducción &mdash; Implementación de un procesador DLX v1.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Implementación de un procesador DLX v1.0 documentation" href="index.html" />
    <link rel="prev" title="Implementación de un procesador DLX" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="index.html" title="Implementación de un procesador DLX"
             accesskey="P">anterior</a> |</li>
        <li><a href="index.html">Implementación de un procesador DLX v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="introducci-n">
<h1>Introducción<a class="headerlink" href="#introducci-n" title="Enlazar permanentemente con este título">¶</a></h1>
<p>En este trabajo se implementa y verifica un procesador DLX utilizando el
lenguaje de programación <a class="reference external" href="http://python.org">Python</a> mediante el uso del paquete <a class="reference external" href="http://myhdl.org">MyHDL</a>. El
proyecto se ha llamado <strong>PyMIPS</strong>.</p>
<p>El DLX es básicamente un procesador MIPS revisado y simplificado con una arquitectura
RISC de 32 bits y un pipeline de 5 etapas. (ver <a class="reference internal" href="#segmentaci-n">Segmentación</a> ). Ha sido pensado
principalmente para propósitos educativos, y se utiliza ampliamente en cursos de
nivel universitario sobre arquitectura de computadoras.</p>
<p>El desarrollo de este trabajo ha sido guiado principalmente por el libro
&#8220;Computer Organization and Design&#8221; <a class="reference internal" href="#patterson-hennessy2005">[Patterson-Hennessy2005]</a>, escrito por David Patterson y John
Hennessy, diseñadores originales del procesador DLX.</p>
<p>El código fuente, la documentación y la visualización de la historia de desarrollo
puede encontrarse en el sitio web <a class="reference external" href="http://github.com/nqnwebs/pymips">http://github.com/nqnwebs/pymips</a>.
El trabajo ha sido liberado bajo licencia GNU GPL v3.0 <a class="footnote-reference" href="#id5" id="id2">[1]</a> .</p>
</div>
<div class="section" id="lenguaje-de-implementaci-n">
<h1>Lenguaje de implementación<a class="headerlink" href="#lenguaje-de-implementaci-n" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Python es un lenguaje de programación de alto nivel cuya filosofía hace hincapié
en una sintáxis clara y legible.</p>
<p>Se trata de un lenguaje de programación multiparadigma ya que soporta
orientación a objetos, programación imperativa y funcional. Es un lenguaje interpretado,
usa tipado dinámico, es fuertemente tipado y es multiplataforma.</p>
<p>MyHDL es un paquete (un conjunto de módulos y funciones Python) que permite utilizar
la potencia de alto nivel de Python en reemplazo de un lenguaje de descripción de hardware
tradicional. Más aun, con algunas restricciones menores, el código Python-MyHDL
es convertible a VHDL o Verilog automáticamente. Puede verse un detalle de
característicsa y ejemplos en el manual de usuario <a class="reference internal" href="#myhdldoc">[MyHDLDoc]</a>.</p>
<p>También es posible generar un archivo de descripción de forma de onda de las
señales (archivos <em>.vcd</em>) implicadas en un determinado diseño.</p>
<p>Es importante destacar que <a class="reference external" href="http://myhdl.org">MyHDL</a> permite valerse de la potencia de Python
como lenguaje de alto nivel, pero sin salirse del <em>scope</em> de la descripción
de hardware. Por ello, muchos conceptos son comunes (señales, bus, bits,
enteros con y sin signo, testbench, etc) así como las técnicas de modelado
(estructural, comportamental, etc.). Semánticamente es muy similar a
Verilog, aunque la posibilidad de instrospección de Python permite automatizar
e inferir aspectos, por ejemplo, el comportamiento de los puertos (se detecta
si es un puerto de entrada o salida).</p>
<p>En el artículo <a class="reference internal" href="#whymyhdl">[WhyMyHDL]</a> se detallan muchas ventajas de su uso. Entre ellas
se destacan:</p>
<blockquote>
<ul class="simple">
<li>Facilidad de uso: Python es mucho más fácil de aprender que VHDL o Verilog</li>
<li>Uso de técnicas modernas de desarrollo de software aplicadas al diseño de hardware:
por ejemplo, pruebas unitarias, y la metodológia asociada <em>“test-driven development”</em></li>
<li>Unificar diseño algoritmico y descripción de hardware</li>
<li>Centralizar el desarrollo cuando hay que codificar lo mismo en VHDL y Verilog</li>
<li>y mucho más...</li>
</ul>
</blockquote>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><a class="reference external" href="http://www.gnu.org/licenses/gpl.html">http://www.gnu.org/licenses/gpl.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="arquitectura">
<h1>Arquitectura<a class="headerlink" href="#arquitectura" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="segmentaci-n">
<h2>Segmentación<a class="headerlink" href="#segmentaci-n" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El interior del procesador DLX está segmentado en cinco etapas de pipeline y
en cada una de ellas se realizarán las operaciones de las tareas en el ciclo
normal de una instrucción, es decir, búsqueda de la instrucción
(identificado con el bloque IF), decodificación de la instrucción
(identificado con el bloque ID), ejecución de la operación
(identificado con el bloque EX), acceso a memoria
(identificado con el bloque MEM) y almacenamiento del resultado de la
operación (identificado con el bloque WB).</p>
<blockquote>
<div align="center" class="align-center"><img alt="_images/segmentation.png" class="align-center" src="_images/segmentation.png" style="width: 80%;" /></div>
</blockquote>
<p>La ejecución de las instrucciones se superponen en el tiempo de la siguiente
manera:</p>
<blockquote>
<div align="center" class="align-center"><img alt="_images/overlapping.png" class="align-center" src="_images/overlapping.png" style="width: 80%;" /></div>
</blockquote>
</div>
</div>
<div class="section" id="implementaci-n">
<h1>Implementación<a class="headerlink" href="#implementaci-n" title="Enlazar permanentemente con este título">¶</a></h1>
<p>El desarrollo de PyMIPS ha sido realizado iterativa e incrementalmente. En
una primera estapa se codificó y verificó cada uno de los componentes internos
del procesador. Luego, a nivel estructural, se instanciaron y conectaron
estos componentes (mediante señales internas) en una versión sin pipeline,
(<a class="reference internal" href="#datapath">Datapath</a>), una versión con pipeline pero sin control de hazards (<a class="reference internal" href="#pipeline">Pipeline</a>),
y la versión definitiva con segmentación y control de hazards,
mediante forwarding y detección de saltos (<cite>DLX</cite>).</p>
<p>La codificación de cada componente respeta las restricciones RTL de MyHDL
para ser convertible a lenguajes HDL sintetizables. En particular, para una
una comparación, se incluye el resultado de conversión automática a VHDL
estándar.</p>
<p>Todos estos componentes han sido verificados y simulados mediante <em>testbenchs</em>
y/o <em>unittests</em>. Ambas técnicas permiten conectar señales a los puertos de
entrada y salida del componte y observar su comportamiento en función de
distintos estímulos que se generan. La diferencia radica en que los
<em>unittest</em>, herramienta incluída en lenguajes orientados a objetos como Java
y C++ y parte neurálgica de modelos de desarrollo ágiles, permiten la verificación automática comparando el estado de una señal en un determinado momento con un el valor esperado para esa condición.</p>
<p>Esta automatización, en contraste con la inspección manual mediante el dump
de forma de onda o la impresión por pantalla, permite una verificación mucho
más fiable y rápida.</p>
<div class="section" id="convenciones-de-c-dificaci-n">
<h2>Convenciones de códificación<a class="headerlink" href="#convenciones-de-c-dificaci-n" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Sobre todo en las implementación a nivel estructural (las distintas versiones
del procesador) la cantidad de señales internas e instancias de componentes
es grande. Para facilitar la diferenciación semántica de cada <em>objeto</em> se
definió la siguiente convención:</p>
<blockquote>
<ul class="simple">
<li>La señales se definen en <tt class="docutils literal"><span class="pre">CamelCase</span></tt></li>
<li>La instancias de componente se escriben como <tt class="docutils literal"><span class="pre">under_score_</span></tt> (con un
<tt class="docutils literal"><span class="pre">_</span></tt> al final)</li>
<li>La señales que se comparten por dos o más etapas (que atraviesan un
latch) tiene como sufijo la etapa de pipeline a la que pertenencen.
Por ejemplo: <tt class="docutils literal"><span class="pre">PcAdderO_if</span></tt>, que se encuentra antes del latch <tt class="docutils literal"><span class="pre">IF/ID</span></tt>
es la misma señal que <tt class="docutils literal"><span class="pre">PcAdderO_id</span></tt> después del latch.</li>
</ul>
</blockquote>
</div>
<div class="section" id="componentes">
<h2>Componentes<a class="headerlink" href="#componentes" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="section" id="program-counter">
<h3>Program Counter<a class="headerlink" href="#program-counter" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El contador de programa funciona como un latch. Cuando llega el flanco de
clock (descendiente), el valor del puerto de salida se actualiza con el valor
del puerto de entrada en ese instante.</p>
<div align="center" class="align-center"><object data="_images/aafig-1dc7aae823bfeac446f2f0c28e4da964bfcf1bb2.svg" height="168.0" type="image/svg+xml" width="327.6"><embed height="168.0" src="_images/aafig-1dc7aae823bfeac446f2f0c28e4da964bfcf1bb2.svg" type="image/svg+xml" width="327.6" /></object>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">program_counter</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">stall</span><span class="o">=</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    clk : clock signal </span>
<span class="sd">    input: the input count</span>
<span class="sd">    output: address output</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">negedge</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stall</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">input</span>

    <span class="k">return</span> <span class="n">update</span>
</pre></div>
</div>
<p>Luego de la conversión a VHDL, el código generado es el siguiente</p>
<div class="highlight-python"><pre>entity program_counter is
    port (
        clk: in unsigned(0 downto 0);
        input: in unsigned(4 downto 0);
        output: out unsigned(4 downto 0)
    );
end entity program_counter;

architecture MyHDL of program_counter is

signal state: unsigned(31 downto 0);

begin


PROGRAM_COUNTER_UP_OUT: process (clk) is
begin
    if rising_edge(clk) then
        output &lt;= resize(state, 5);
    end if;
end process PROGRAM_COUNTER_UP_OUT;

PROGRAM_COUNTER_UP_STATE: process (clk) is
begin
    if falling_edge(clk) then
        state &lt;= resize(input, 32);
    end if;
end process PROGRAM_COUNTER_UP_STATE;

end architecture MyHDL;
</pre>
</div>
<p>Para la verificación se realizó el siguiente <em>TestBench</em> que emula el uso en
el contexto real donde el valor de salida (el contador) se incremeta a traves
de un sumador</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">testbench</span><span class="p">():</span>

    <span class="n">clk</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">32</span><span class="p">))</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">32</span><span class="p">))</span>

    <span class="n">clkdriver_inst</span> <span class="o">=</span> <span class="n">clock_driver</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span>
    <span class="n">pc_inst</span> <span class="o">=</span> <span class="n">program_counter</span><span class="p">(</span> <span class="n">clk</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
    
    
    <span class="n">c</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="mf">0</span><span class="n">b0010</span><span class="p">)</span>
    <span class="n">alu_i</span> <span class="o">=</span> <span class="n">ALU</span><span class="p">(</span> <span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">Signal</span><span class="p">(</span><span class="mf">1</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">Signal</span><span class="p">(</span><span class="mf">0</span><span class="p">))</span>


    <span class="nd">@instance</span>
    <span class="k">def</span> <span class="nf">stimulus</span><span class="p">():</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;time: </span><span class="si">%s</span><span class="s"> | Clock: </span><span class="si">%i</span><span class="s"> | in: </span><span class="si">%i</span><span class="s"> | out: </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">now</span><span class="p">(),</span> <span class="n">clk</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">instances</span><span class="p">()</span>
</pre></div>
</div>
<p>El resultado es el siguiente:</p>
<div class="highlight-text"><div class="highlight"><pre>time: 1 | Clock: 0 | in: 1 | out: 0
time: 2 | Clock: 1 | in: 1 | out: 0
time: 3 | Clock: 0 | in: 2 | out: 1
time: 4 | Clock: 1 | in: 2 | out: 1
time: 5 | Clock: 0 | in: 3 | out: 2
time: 6 | Clock: 1 | in: 3 | out: 2
time: 7 | Clock: 0 | in: 4 | out: 3
time: 8 | Clock: 1 | in: 4 | out: 3
time: 9 | Clock: 0 | in: 5 | out: 4
time: 10 | Clock: 1 | in: 5 | out: 4
time: 11 | Clock: 0 | in: 6 | out: 5
time: 12 | Clock: 1 | in: 6 | out: 5
time: 13 | Clock: 0 | in: 7 | out: 6
time: 14 | Clock: 1 | in: 7 | out: 6
time: 15 | Clock: 0 | in: 8 | out: 7
time: 16 | Clock: 1 | in: 8 | out: 7
time: 17 | Clock: 0 | in: 9 | out: 8
time: 18 | Clock: 1 | in: 9 | out: 8
time: 19 | Clock: 0 | in: 10 | out: 9
time: 20 | Clock: 1 | in: 10 | out: 9
</pre></div>
</div>
</div>
<div class="section" id="instruction-memory">
<h3>Instruction Memory<a class="headerlink" href="#instruction-memory" title="Enlazar permanentemente con este título">¶</a></h3>
<div align="center" class="align-center"><object data="_images/aafig-07575f15d0448ac3a3258adfac47990292fd7d79.svg" height="189.0" type="image/svg+xml" width="630.0"><embed height="189.0" src="_images/aafig-07575f15d0448ac3a3258adfac47990292fd7d79.svg" type="image/svg+xml" width="630.0" /></object>
</div>
<p>Una de las características de la arquitectura Hardvard del DLX es la
separación de la memoria de programa de la memoria de datos.
La memoria de programas funciona como una memoria ROM. En particular
el diseño implementado distribuye la memoria en bancos de 32 bits en vez de
bytes. Esto tiene implicancia en que el incremento entre una instrucción
y otra es de 1 en 1, en vez de ser de 4 como utiliza el diseño de la
bibliografía.</p>
<p>Cuando llega un flanco descendiente en el clock, el dato guardado en la
dirección de memoria de entrada se asigna a la salida.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">instruction_memory</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">instruction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    address -- the pointer defined by PC </span>
<span class="sd">    instruction -- 32 bit encoded instruction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
            <span class="n">instruction</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ROM</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">address</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">logic</span>
</pre></div>
</div>
<p>Por simplicidad, no se incluye el código autogenerado de la conversión a
VHDL, pero como para todos los componentes, puede encontrarse en la carpeta
* ./vhdl *</p>
<p>Para cargar de información la memoria ROM, se escribió una pequeña función
que lee un archivo de texto, considerando el <em>token</em> <tt class="docutils literal"><span class="pre">#</span></tt> como el inicio
de un cometario. Además, no se consideran los espacios, de manera que el
resultado es un número binario de 32 digitos (una instrucción de programa).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">load_program</span><span class="p">(</span><span class="n">ROM</span><span class="p">,</span> <span class="n">program</span><span class="o">=</span><span class="s">&#39;/home/tin/facu/arq/project/prog.txt&#39;</span><span class="p">,</span> <span class="n">comment_char</span><span class="o">=</span><span class="s">&#39;#&#39;</span> <span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">comment_char</span><span class="p">)[</span><span class="mf">0</span><span class="p">]</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">==</span> <span class="mf">32</span><span class="p">:</span>
            <span class="n">ROM</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mf">1</span> 

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ROM</span><span class="p">)</span>
</pre></div>
</div>
<p>El testbench lee las 8 primeras posiciones:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">testBench</span><span class="p">():</span>

    <span class="n">I</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">16</span><span class="p">))</span>
    <span class="n">O</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">32</span><span class="p">:])</span>
    

    <span class="c">#pd_instance = prime_detector(E, S)</span>
    <span class="n">im_instance</span> <span class="o">=</span> <span class="n">toVHDL</span><span class="p">(</span><span class="n">instruction_memory</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">O</span><span class="p">)</span>

    <span class="nd">@instance</span>
    <span class="k">def</span> <span class="nf">stimulus</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">8</span><span class="p">):</span>
            <span class="n">I</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;address: &quot;</span> <span class="o">+</span> <span class="n">bin</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mf">4</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;) | instruction: &quot;</span> <span class="o">+</span> <span class="n">bin</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="mf">32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">instances</span><span class="p">()</span>
</pre></div>
</div>
<p>cuyo resultado es el siguiente:</p>
<div class="highlight-text"><div class="highlight"><pre>address: 0000 (0) | instruction: 00000000010000110000100000100000
address: 0001 (1) | instruction: 00000000001001000000000000100010
address: 0010 (2) | instruction: 10101100001000100000000000000101
address: 0011 (3) | instruction: 10001100001000000000000000000101
address: 0100 (4) | instruction: 00000000000000000000000000000000
address: 0101 (5) | instruction: 00000000000000000000000000000000
address: 0110 (6) | instruction: 00000000000000000000000000000000
address: 0111 (7) | instruction: 00000000000000000000000000000000
</pre></div>
</div>
</div>
<div class="section" id="instruction-decoder">
<h3>Instruction Decoder<a class="headerlink" href="#instruction-decoder" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En los 32 bits de instrucción se codifican distintas informaciones: opcode,
función, registro source, target y destiny, etc. Para realizar esta
separación se implementó un simple decodificador combinacional.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">instruction_dec</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">shamt</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">NopSignal</span><span class="o">=</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Decode segments of 32bits encoded instruction</span>

<span class="sd">    instruction: 32 bits </span>
<span class="sd">    rs = Signal(intbv(0)[5:])       #instruction 25:21  - to read_reg_1</span>
<span class="sd">    rt = Signal(intbv(0)[5:])       #instruction 20:16  - to read_reg_2 and mux controlled by RegDst</span>
<span class="sd">    rd = Signal(intbv(0)[5:])       #instruction 15:11  - to the mux controlled by RegDst</span>
<span class="sd">    shamt = Signal(intbv(0)[5:])    #instruction 10:6   - </span>
<span class="sd">    func = Signal(intbv(0)[6:])     #instruction 5:0    - to ALUCtrl</span>
<span class="sd">    address = Signal(intbv(0)[16:]) #instruction 15:0   - to Sign Extend</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">decode</span><span class="p">():</span>
        <span class="n">opcode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mf">32</span><span class="p">:</span><span class="mf">26</span><span class="p">]</span>
        <span class="n">rs</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mf">26</span><span class="p">:</span><span class="mf">21</span><span class="p">]</span>         <span class="c">#- to read_reg_1</span>
        <span class="n">rt</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mf">21</span><span class="p">:</span><span class="mf">16</span><span class="p">]</span>         <span class="c">#- to read_reg_2 and mux controlled by RegDst</span>
        <span class="n">rd</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mf">16</span><span class="p">:</span><span class="mf">11</span><span class="p">]</span>         <span class="c">#- to the mux controlled by RegDst</span>
        <span class="n">shamt</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mf">11</span><span class="p">:</span><span class="mf">6</span><span class="p">]</span>   
        <span class="n">func</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mf">6</span><span class="p">:</span><span class="mf">0</span><span class="p">]</span>         <span class="c">#- to ALUCtrl</span>
        <span class="n">address</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="mf">16</span><span class="p">:</span><span class="mf">0</span><span class="p">]</span><span class="o">.</span><span class="n">signed</span><span class="p">()</span>     <span class="c">#- to Sign Extend</span>


        <span class="k">if</span> <span class="n">instruction</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span>
            <span class="n">NopSignal</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">NopSignal</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>

    <span class="k">return</span> <span class="n">decode</span>
</pre></div>
</div>
</div>
<div class="section" id="unidad-de-control">
<h3>Unidad de control<a class="headerlink" href="#unidad-de-control" title="Enlazar permanentemente con este título">¶</a></h3>
<div align="center" class="align-center"><object data="_images/aafig-4e8993a148c90510f2f071ac2db97ca80dc6fd55.svg" height="231.0" type="image/svg+xml" width="592.2"><embed height="231.0" src="_images/aafig-4e8993a148c90510f2f071ac2db97ca80dc6fd55.svg" type="image/svg+xml" width="592.2" /></object>
</div>
<p>La unidad de control es un componente combinacional que activa <em>flags</em>, en
general para el control de multiplexores u otras unidades de control
secundarias. Cumple la siguiente tabla de verdad:</p>
<img alt="_images/control_table.png" src="_images/control_table.png" style="width: 90%;" />
<p>Para satisfacer la detección de <tt class="docutils literal"><span class="pre">nop</span></tt> (instrucción <tt class="docutils literal"><span class="pre">0x00000</span></tt>) se
incorporó como entrada una señal detectada en ID, que es <tt class="docutils literal"><span class="pre">1</span></tt> si toda la
instrucción es <tt class="docutils literal"><span class="pre">0</span></tt>. En tal caso , la unidad de control pone todas sus
salidas a <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>La modificación  se debe a que el opcode <tt class="docutils literal"><span class="pre">00000</span></tt> es común para las
instrucciones R-type y algunas señales de
control se ponen a <tt class="docutils literal"><span class="pre">1</span></tt> causando efectos no deseados como la escritura en el
banco de registros.</p>
<p>El código de implementación es el siguiente</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">control</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="n">RegDst</span><span class="p">,</span> <span class="n">Branch</span><span class="p">,</span> <span class="n">MemRead</span><span class="p">,</span> <span class="n">MemtoReg</span><span class="p">,</span> <span class="n">ALUop</span><span class="p">,</span> 
            <span class="n">MemWrite</span><span class="p">,</span> <span class="n">ALUSrc</span><span class="p">,</span> <span class="n">RegWrite</span><span class="p">,</span> <span class="n">NopSignal</span><span class="o">=</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:]),</span> <span class="n">Stall</span><span class="o">=</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    opcode -- 6bit opcode field from instruction</span>
<span class="sd">    RegDst, ALUSrc, MemtoReg -- 1bit signals to control multiplexors</span>
<span class="sd">    RegWrite, MemRead, MemWrite -- 1bit signals to control reads and writes </span>
<span class="sd">                                   in registers and memory</span>
<span class="sd">    Branch -- 1bit signal to determining whether to possibly branch</span>
<span class="sd">    ALUop -- 2bit control signal for the ALU</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">NopSignal</span> <span class="o">==</span> <span class="mf">1</span> <span class="ow">or</span> <span class="n">Stall</span> <span class="o">==</span> <span class="mf">1</span><span class="p">:</span>
            <span class="n">RegDst</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">ALUSrc</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">MemtoReg</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">RegWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">MemRead</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">MemWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">Branch</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">ALUop</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;00&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span>     <span class="c">#r-format</span>
                <span class="n">RegDst</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
                <span class="n">ALUSrc</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">MemtoReg</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">RegWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
                <span class="n">MemRead</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">MemWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">Branch</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">ALUop</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;10&#39;</span><span class="p">)</span>
            
            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mf">0</span><span class="n">x23</span><span class="p">:</span> <span class="c">#lw</span>
                <span class="n">RegDst</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">ALUSrc</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
                <span class="n">MemtoReg</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
                <span class="n">RegWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
                <span class="n">MemRead</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
                <span class="n">MemWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">Branch</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">ALUop</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;00&#39;</span><span class="p">)</span>   
     
            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mf">0</span><span class="n">x2b</span><span class="p">:</span> <span class="c">#sw</span>
                <span class="n">ALUSrc</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
                <span class="n">RegWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">MemRead</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">MemWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
                <span class="n">Branch</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">ALUop</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;00&#39;</span><span class="p">)</span>   

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="mf">0</span><span class="n">x04</span><span class="p">:</span> <span class="c">#beq</span>
                <span class="n">ALUSrc</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">RegWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">MemRead</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">MemWrite</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
                <span class="n">Branch</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
                <span class="n">ALUop</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;01&#39;</span><span class="p">)</span>   

    <span class="k">return</span> <span class="n">logic</span>
</pre></div>
</div>
<p>El testbench desarrollado itera sobre distintas entradas de opcode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">testBench</span><span class="p">():</span>

    <span class="n">signal_1bit</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">7</span><span class="p">)]</span>
    <span class="n">RegDst</span><span class="p">,</span> <span class="n">ALUSrc</span><span class="p">,</span> <span class="n">MemtoReg</span><span class="p">,</span> <span class="n">RegWrite</span><span class="p">,</span> <span class="n">MemRead</span><span class="p">,</span> <span class="n">MemWrite</span><span class="p">,</span> <span class="n">Branch</span> <span class="o">=</span> <span class="n">signal_1bit</span>
    <span class="n">ALUop</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">2</span><span class="p">:])</span>

    <span class="n">opcode</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">6</span><span class="p">:])</span>

    <span class="n">control_inst</span> <span class="o">=</span> <span class="n">toVHDL</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">RegDst</span><span class="p">,</span> <span class="n">Branch</span><span class="p">,</span> <span class="n">MemRead</span><span class="p">,</span> <span class="n">MemtoReg</span><span class="p">,</span> <span class="n">ALUop</span><span class="p">,</span> <span class="n">MemWrite</span><span class="p">,</span> <span class="n">ALUSrc</span><span class="p">,</span> <span class="n">RegWrite</span><span class="p">)</span>

    <span class="nd">@instance</span>
    <span class="k">def</span> <span class="nf">stimulus</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">op_value</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;100011&#39;</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;101011&#39;</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;000100&#39;</span><span class="p">,</span> <span class="mf">2</span><span class="p">)]:</span>
            <span class="n">opcode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">op_value</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>

            <span class="k">print</span> <span class="s">&#39;opcode: &#39;</span><span class="p">,</span> <span class="n">bin</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="mf">6</span><span class="p">)</span>
            <span class="k">print</span> <span class="n">RegDst</span><span class="p">,</span> <span class="n">ALUSrc</span><span class="p">,</span> <span class="n">MemtoReg</span><span class="p">,</span> <span class="n">RegWrite</span><span class="p">,</span> <span class="n">MemRead</span><span class="p">,</span> <span class="n">MemWrite</span><span class="p">,</span> <span class="n">Branch</span><span class="p">,</span> <span class="n">bin</span><span class="p">(</span><span class="n">ALUop</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span>
        


    <span class="k">return</span> <span class="n">instances</span><span class="p">()</span>
</pre></div>
</div>
<p>Cuyo salida estándar es la siguiente:</p>
<div class="highlight-text"><div class="highlight"><pre>opcode:  000000
1 0 0 1 0 0 0 10
opcode:  100011
0 1 1 1 1 0 0 00
opcode:  101011
0 1 1 0 0 1 0 00
opcode:  000100
0 0 1 0 0 0 1 01
</pre></div>
</div>
</div>
<div class="section" id="multiplexores">
<h3>Multiplexores<a class="headerlink" href="#multiplexores" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para seleccionar una u otra entrada en función de señales gestionadas por
unidades de control se utilizan multiplexores, en particular de 2x32 (2
canaes de 32 bits) y 4x32.</p>
<div align="center" class="align-center"><object data="_images/aafig-5ab075234801f6ca61e052085156eb596c55b9e1.svg" height="168.0" type="image/svg+xml" width="277.2"><embed height="168.0" src="_images/aafig-5ab075234801f6ca61e052085156eb596c55b9e1.svg" type="image/svg+xml" width="277.2" /></object>
</div>
<p>Si el selector es 0, la salida se conectará con el canal 0, y análogamente
si es 1 la salida será el canal 1. Para los multiplexores de 4 canales, el
selector en una señal de 2 bits.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">mux2</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">mux_out</span><span class="p">,</span> <span class="n">chan1</span><span class="p">,</span> <span class="n">chan2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2-channels m-bits multiplexor</span>

<span class="sd">    channels: generic bits input vectors</span>
<span class="sd">    mux_out: is the output vector</span>
<span class="sd">    sel: is the channel selector</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">route_channel</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">sel</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span>
            <span class="n">mux_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">chan1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mux_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">chan2</span>

    <span class="k">return</span> <span class="n">route_channel</span>
</pre></div>
</div>
<p>El testbench genera entradas y selectores al azar e imprime la salida. Una
salida es la siguiente:</p>
<div class="highlight-text"><div class="highlight"><pre>Inputs: 123 200 | S: 0 | Output: 0
Inputs: 12 186 | S: 1 | Output: 186
Inputs: 11 198 | S: 1 | Output: 198
Inputs: 248 108 | S: 1 | Output: 108
Inputs: 92 39 | S: 0 | Output: 92
Inputs: 112 147 | S: 1 | Output: 147
Inputs: 12 159 | S: 1 | Output: 159
Inputs: 159 17 | S: 1 | Output: 17
Inputs: 92 115 | S: 1 | Output: 115
Inputs: 36 149 | S: 0 | Output: 36
Inputs: 232 75 | S: 1 | Output: 75
Inputs: 112 218 | S: 0 | Output: 112
Inputs: 219 40 | S: 1 | Output: 40
Inputs: 201 177 | S: 1 | Output: 177
Inputs: 114 99 | S: 1 | Output: 99
Inputs: 121 43 | S: 0 | Output: 121
Inputs: 147 16 | S: 1 | Output: 16
Inputs: 205 52 | S: 1 | Output: 52
Inputs: 111 23 | S: 0 | Output: 111
Inputs: 96 113 | S: 1 | Output: 113
Inputs: 164 39 | S: 0 | Output: 164
</pre></div>
</div>
</div>
<div class="section" id="banco-de-registros">
<h3>Banco de Registros<a class="headerlink" href="#banco-de-registros" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El DLX cuenta con un banco de 32 registros de propósito general. Tiene la
particularidad de que en un mismo ciclo puede leer 2 registros
simultáneamente (en el flanco de bajada) y escribir, si está habilitada la
correspondiente señal de escritura, 1 registro en el flanco de subida del
clock.</p>
<div align="center" class="align-center"><object data="_images/aafig-7603e46b4d7ef3915c356ce3a49d6820f04adf35.svg" height="336.0" type="image/svg+xml" width="567.0"><embed height="336.0" src="_images/aafig-7603e46b4d7ef3915c356ce3a49d6820f04adf35.svg" type="image/svg+xml" width="567.0" /></object>
</div>
</div>
<div class="section" id="alu">
<h3>ALU<a class="headerlink" href="#alu" title="Enlazar permanentemente con este título">¶</a></h3>
<div align="center" class="align-center"><object data="_images/aafig-02985812f949eb34fd421d9dccea607241b300ff.svg" height="357.0" type="image/svg+xml" width="466.2"><embed height="357.0" src="_images/aafig-02985812f949eb34fd421d9dccea607241b300ff.svg" type="image/svg+xml" width="466.2" /></object>
</div>
<p>La unidad aritmético-lógica es la encargada de realizar las operaciones.
El operando de 32bits <tt class="docutils literal"><span class="pre">Data1</span></tt> recibe el dato del registro 1 (<tt class="docutils literal"><span class="pre">Rs</span></tt>) y <tt class="docutils literal"><span class="pre">Data2</span></tt>
puede ser tanto otro dato almacenado en un registro (<tt class="docutils literal"><span class="pre">Rt</span></tt>) o bien un valor
literal. Las operaciones que soporta esta implementación son las que se
detallan en la siguiente tabla.</p>
<div align="center" class="align-center"><img alt="_images/alu_op.png" class="align-center" src="_images/alu_op.png" /></div>
<p>La implementación es la siguiente:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">ALU</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">out_</span><span class="p">,</span> <span class="n">zero</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    control : 4 bit control/selector vector.</span>
<span class="sd">    op1: operator 1. 32bits</span>
<span class="sd">    op2: operator 2. 32bits</span>
<span class="sd">    out: ALU result. 32bits</span>
<span class="sd">    zero: zero detector. ``1`` when out is 0. </span>

<span class="sd">    =============  =======================</span>
<span class="sd">     ALU control    Function</span>
<span class="sd">    =============  =======================</span>
<span class="sd">     0000           AND</span>
<span class="sd">     0001           OR</span>
<span class="sd">     0010           add</span>
<span class="sd">     0110           substract</span>
<span class="sd">     0111           set on less than</span>
<span class="sd">     1100           NOR</span>
<span class="sd">    =============  =======================</span>

<span class="sd">    &quot;&quot;&quot;</span>

    

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">logic_alu</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">control</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span> <span class="c">#int(&#39;0000&#39;,2):</span>
            <span class="n">out_</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span>  <span class="n">op1</span> <span class="o">&amp;</span> <span class="n">op2</span>

        <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="mf">1</span> <span class="p">:</span> <span class="c">#int(&#39;0001&#39;,2):</span>
            <span class="n">out_</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span>  <span class="n">op1</span> <span class="o">|</span> <span class="n">op2</span>

        <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="mf">2</span> <span class="p">:</span> <span class="c">#int(&#39;0010&#39;,2):</span>
            <span class="n">out_</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span>  <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span>           <span class="c">#what happend if there is overflow ?</span>
       
        <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="mf">6</span> <span class="p">:</span> <span class="c"># int(&#39;0110&#39;,2):</span>
            <span class="n">out_</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span>  <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span>
            

        <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="mf">0</span><span class="n">b0111</span> <span class="p">:</span> <span class="c">#int(&#39;0111&#39;,2):</span>
            <span class="k">if</span> <span class="n">op1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">op2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">out_</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>

        <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="mf">12</span> <span class="p">:</span> <span class="c">#int(&#39;1100&#39;, 2):</span>
            <span class="n">out_</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span>  <span class="o">~</span> <span class="p">(</span><span class="n">op1</span> <span class="o">|</span> <span class="n">op2</span><span class="p">)</span>   <span class="c">#TODO check this</span>
    

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">zero_detector</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">out_</span> <span class="o">==</span> <span class="mf">0</span><span class="p">:</span>
            <span class="n">zero</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zero</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>

    <span class="k">return</span> <span class="n">logic_alu</span><span class="p">,</span> <span class="n">zero_detector</span>


<span class="c">### TESTBENCHS</span>
</pre></div>
</div>
<p>El testbench genera inputs al azar e intera sobre los valores de gestión
válidos. La salida es la siguiente</p>
<div class="highlight-python"><pre>Control: 0000 | 252 AND 184 | 184 | z=0
Control: 0001 | 137 OR 175 | 175 | z=0
Control: 0010 | 113 add 148 | 261 | z=0
Control: 0110 | 77 substract 166 | -89 | z=0
Control: 0111 | 158 &lt; 10 | 0 | z=1
Control: 1100 | 238 NOR 237 | -240 | z=0</pre>
</div>
</div>
<div class="section" id="alu-control">
<h3>ALU Control<a class="headerlink" href="#alu-control" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La unidad de control de ALU es un componente combinacional de control
secundario. Recibe una señal de 2 bits de la unidad de control y la función
codificada en los 6 bits menos significativos de la instrucción.
Genera la señal de control de 4 bits correspondiente para controlar la
operación de la ALU.</p>
<div align="center" class="align-center"><object data="_images/aafig-662ae44c60e370d0124c5909aa7ddd188f4b0fce.svg" height="126.0" type="image/svg+xml" width="516.6"><embed height="126.0" src="_images/aafig-662ae44c60e370d0124c5909aa7ddd188f4b0fce.svg" type="image/svg+xml" width="516.6" /></object>
</div>
<p>La tabla de verdad es la siguiente:</p>
<div align="center" class="align-center"><img alt="_images/alu_control.png" class="align-center" src="_images/alu_control.png" /></div>
<p>La implementación es la siguiente:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">alu_control</span><span class="p">(</span><span class="n">aluop</span><span class="p">,</span> <span class="n">funct_field</span><span class="p">,</span> <span class="n">control_out</span><span class="p">):</span>
    

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aluop</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">aluop</span><span class="p">[</span><span class="mf">1</span><span class="p">]:</span>
            <span class="n">control_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;0010&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">aluop</span><span class="p">[</span><span class="mf">0</span><span class="p">]:</span>
            <span class="n">control_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;0110&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">aluop</span><span class="p">[</span><span class="mf">1</span><span class="p">]:</span>
           
            <span class="k">if</span> <span class="n">bin</span><span class="p">(</span><span class="n">funct_field</span><span class="p">[</span><span class="mf">3</span><span class="p">:],</span> <span class="mf">4</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;0000&#39;</span><span class="p">:</span>
                <span class="n">control_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;0010&#39;</span><span class="p">)</span>
            
            <span class="k">elif</span> <span class="n">bin</span><span class="p">(</span><span class="n">funct_field</span><span class="p">[</span><span class="mf">3</span><span class="p">:],</span> <span class="mf">4</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;0010&#39;</span><span class="p">:</span>
                <span class="n">control_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;0110&#39;</span><span class="p">)</span>
                
            <span class="k">elif</span> <span class="n">bin</span><span class="p">(</span><span class="n">funct_field</span><span class="p">[</span><span class="mf">3</span><span class="p">:],</span> <span class="mf">4</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;0100&#39;</span><span class="p">:</span>
                <span class="n">control_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;0000&#39;</span><span class="p">)</span>
        
            <span class="k">elif</span> <span class="n">bin</span><span class="p">(</span><span class="n">funct_field</span><span class="p">[</span><span class="mf">3</span><span class="p">:],</span> <span class="mf">4</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;0101&#39;</span><span class="p">:</span>
                <span class="n">control_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;0001&#39;</span><span class="p">)</span>
        
            <span class="k">elif</span> <span class="n">bin</span><span class="p">(</span><span class="n">funct_field</span><span class="p">[</span><span class="mf">3</span><span class="p">:],</span> <span class="mf">4</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;1010&#39;</span><span class="p">:</span>
                <span class="n">control_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="s">&#39;0111&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">control_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
        <span class="c">#else:</span>
        <span class="c">#    control_out.next = intbv(0)</span>


    <span class="k">return</span> <span class="n">logic</span>


        
</pre></div>
</div>
<p>El testbench se codificó de la siguiente manera:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">testBench_alu_control</span><span class="p">():</span>

    <span class="n">aluop_i</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">2</span><span class="p">:])</span>
    <span class="n">funct_field_i</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">6</span><span class="p">:])</span>
    <span class="n">alu_control_lines</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">4</span><span class="p">:])</span>

    <span class="n">alu_control_i</span> <span class="o">=</span> <span class="n">toVHDL</span><span class="p">(</span><span class="n">alu_control</span><span class="p">,</span> <span class="n">aluop_i</span><span class="p">,</span> <span class="n">funct_field_i</span><span class="p">,</span> <span class="n">alu_control_lines</span><span class="p">)</span>

    <span class="nd">@instance</span>
    <span class="k">def</span> <span class="nf">stimulus</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">4</span><span class="p">):</span>
            <span class="n">aluop_i</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">2</span><span class="o">**</span><span class="mf">6</span><span class="p">):</span>

                <span class="n">funct_field_i</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&quot;aluop: </span><span class="si">%s</span><span class="s"> | funct field: </span><span class="si">%s</span><span class="s"> | alu_control_lines: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bin</span><span class="p">(</span><span class="n">aluop_i</span><span class="p">,</span> <span class="mf">2</span><span class="p">),</span> <span class="n">bin</span><span class="p">(</span><span class="n">funct_field_i</span><span class="p">,</span> <span class="mf">6</span> <span class="p">),</span> <span class="n">bin</span><span class="p">(</span><span class="n">alu_control_lines</span><span class="p">,</span> <span class="mf">4</span><span class="p">))</span> 
            
    <span class="k">return</span> <span class="n">instances</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="sign-extender">
<h3>Sign Extender<a class="headerlink" href="#sign-extender" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El extensor de signo convierte un dirección (offset) o un literal codificado
en 16 bits (bits 15 a 0 de la instrucción) en un entero de igual valor pero
representado en 32 bits, lo que permite usarlo como operador en la ALU o en
el sumador para saltos condicionales.</p>
<div align="center" class="align-center"><object data="_images/aafig-60c3a863f60b32998041347d9f73747102918a2b.svg" height="147.0" type="image/svg+xml" width="390.6"><embed height="147.0" src="_images/aafig-60c3a863f60b32998041347d9f73747102918a2b.svg" type="image/svg+xml" width="390.6" /></object>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sign_extend</span><span class="p">(</span><span class="n">input16</span><span class="p">,</span> <span class="n">output32</span><span class="p">):</span>
    
    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
        <span class="n">output32</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">input16</span><span class="o">.</span><span class="n">val</span>

    <span class="k">return</span> <span class="n">logic</span>
</pre></div>
</div>
<p>Se muestra tambien la conversión a VHDL</p>
<div class="highlight-python"><pre>entity sign_extend is
    port (
        input16: in signed (15 downto 0);
        output32: out signed (31 downto 0)
    );
end entity sign_extend;

architecture MyHDL of sign_extend is


begin



output32 &lt;= resize(input16, 32);

end architecture MyHDL;
</pre>
</div>
<p>El resulado del testbench es el siguiente:</p>
<div class="highlight-text"><div class="highlight"><pre>In: 0000000000000000 (0) | Out: 00000000000000000000000000000000 (0)
In: 0001001000101001 (4649) | Out: 00000000000000000001001000101001 (4649)
In: 0000110000100111 (3111) | Out: 00000000000000000000110000100111 (3111)
In: 1010000010011011 (-24421) | Out: 11111111111111111010000010011011 (-24421)
In: 0100011000000110 (17926) | Out: 00000000000000000100011000000110 (17926)
In: 0100110001001011 (19531) | Out: 00000000000000000100110001001011 (19531)
In: 0011001110101111 (13231) | Out: 00000000000000000011001110101111 (13231)
In: 1010110110101010 (-21078) | Out: 11111111111111111010110110101010 (-21078)
In: 0000000100000010 (258) | Out: 00000000000000000000000100000010 (258)
In: 1010001110010000 (-23664) | Out: 11111111111111111010001110010000 (-23664)
In: 1000001010011110 (-32098) | Out: 11111111111111111000001010011110 (-32098)
In: 1001111001010100 (-25004) | Out: 11111111111111111001111001010100 (-25004)
In: 0010110011010000 (11472) | Out: 00000000000000000010110011010000 (11472)
In: 0100111101010010 (20306) | Out: 00000000000000000100111101010010 (20306)
In: 1111100011111010 (-1798) | Out: 11111111111111111111100011111010 (-1798)
In: 0001111010111011 (7867) | Out: 00000000000000000001111010111011 (7867)
In: 0100101111110010 (19442) | Out: 00000000000000000100101111110010 (19442)
In: 1111001110010101 (-3179) | Out: 11111111111111111111001110010101 (-3179)
In: 0111000110010110 (29078) | Out: 00000000000000000111000110010110 (29078)
In: 1101100111011100 (-9764) | Out: 11111111111111111101100111011100 (-9764)
In: 1010010011011011 (-23333) | Out: 11111111111111111010010011011011 (-23333)
In: 1010011100111010 (-22726) | Out: 11111111111111111010011100111010 (-22726)
In: 0101001110110100 (21428) | Out: 00000000000000000101001110110100 (21428)
In: 0000001010010011 (659) | Out: 00000000000000000000001010010011 (659)
In: 0001001000011001 (4633) | Out: 00000000000000000001001000011001 (4633)
In: 1111110100101011 (-725) | Out: 11111111111111111111110100101011 (-725)
In: 0001101111010010 (7122) | Out: 00000000000000000001101111010010 (7122)
In: 1011000011110100 (-20236) | Out: 11111111111111111011000011110100 (-20236)
In: 0001100111011111 (6623) | Out: 00000000000000000001100111011111 (6623)
In: 1010010010001011 (-23413) | Out: 11111111111111111010010010001011 (-23413)
In: 0010011100000000 (9984) | Out: 00000000000000000010011100000000 (9984)
In: 1100100110100011 (-13917) | Out: 11111111111111111100100110100011 (-13917)
</pre></div>
</div>
</div>
<div class="section" id="data-memory">
<h3>Data Memory<a class="headerlink" href="#data-memory" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La memoria de datos (RAM) permite almacenar y recuperar información. En el
MIPS y derivados, sólo se interactua con este dispositivo a través de las
operaciones <tt class="docutils literal"><span class="pre">store</span></tt> y <tt class="docutils literal"><span class="pre">load</span></tt>.</p>
<div align="center" class="align-center"><object data="_images/aafig-7838c5a63dc24862c2623228d6bfedf15fb43005.svg" height="252.0" type="image/svg+xml" width="554.4"><embed height="252.0" src="_images/aafig-7838c5a63dc24862c2623228d6bfedf15fb43005.svg" type="image/svg+xml" width="554.4" /></object>
</div>
<p>En cierta forma funciona similar al banco de registros, pero se lee una
dirección a la vez y existen señales de habilitación tanto para escritura
como para lectura. La lectura o la escritura se produce en el flanco de bajada
de la señal de clock, teniendo prioridad la escritura, siempre y cuando las
correspondientes señales estén en <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
<p>La implementación es la siguiente</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">data_memory</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">write_data</span><span class="p">,</span> <span class="n">read_data</span><span class="p">,</span> <span class="n">memread</span><span class="p">,</span> <span class="n">memwrite</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ports:</span>

<span class="sd">    clk -- trigger</span>
<span class="sd">    read_data -- data out</span>
<span class="sd">    write_data -- data in</span>
<span class="sd">    address -- address bus</span>
<span class="sd">    memwrite -- write enable: write if 1</span>
<span class="sd">    memread -- interface enable: read address if 1</span>
<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="n">mem</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="p">(</span><span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="p">),</span> <span class="nb">max</span><span class="o">=</span><span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="o">-</span><span class="mf">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1024</span><span class="p">)]</span>

    <span class="n">mem</span><span class="p">[</span><span class="mf">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">51</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="p">(</span><span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="p">),</span> <span class="nb">max</span><span class="o">=</span><span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="o">-</span><span class="mf">1</span><span class="p">))</span>      <span class="c">#usefull to test load instruction directly</span>
    
    <span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">negedge</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">memwrite</span> <span class="o">==</span> <span class="mf">1</span><span class="p">:</span>
            <span class="n">mem</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">address</span><span class="p">)]</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">write_data</span><span class="o">.</span><span class="n">val</span>
    
        <span class="k">elif</span> <span class="n">memread</span> <span class="o">==</span> <span class="mf">1</span><span class="p">:</span>
            <span class="n">read_data</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">address</span><span class="p">)]</span>

        <span class="c">#print &#39;mem:&#39;, [int(i) for i in mem][0:20]</span>

    <span class="k">return</span> <span class="n">logic</span>
</pre></div>
</div>
<p>La conversión a código VHDL se detalla a continuación:</p>
<div class="highlight-python"><pre>entity data_memory is
    port (
        clk: in unsigned(0 downto 0);
        address: in unsigned(31 downto 0);
        write_data: in signed (31 downto 0);
        read_data: out signed (31 downto 0);
        memread: in unsigned(0 downto 0);
        memwrite: in unsigned(0 downto 0)
    );
end entity data_memory;

architecture MyHDL of data_memory is

type t_array_mem is array(0 to 1024-1) of signed (31 downto 0);
signal mem: t_array_mem;

begin


DATA_MEMORY_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (memwrite = 1) then
            mem(to_integer(address)) &lt;= write_data;
        elsif (memread = 1) then
            read_data &lt;= mem(to_integer(address));
        end if;
    end if;
end process DATA_MEMORY_LOGIC;

end architecture MyHDL;
</pre>
</div>
<p>El testbench realiza escrituras de valores al azar (enteros con signo de 32
bits) en 5 direcciones aleatorias. Luego realiza la lectura de esas
direcciones. Se codificó de la siguiente manera:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">testBench</span><span class="p">():</span>

    <span class="n">depth</span> <span class="o">=</span> <span class="mf">5</span>

    <span class="n">address</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">32</span><span class="p">:])</span> 

    <span class="n">data_in</span><span class="p">,</span> <span class="n">data_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="p">(</span><span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="p">),</span><span class="nb">max</span><span class="o">=</span><span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="o">-</span><span class="mf">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">2</span><span class="p">)]</span>

    <span class="n">clk</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">1</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span>
    <span class="n">write_control</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span>
    <span class="n">read_control</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span>

    <span class="n">memory_i</span> <span class="o">=</span> <span class="n">data_memory</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">data_in</span><span class="p">,</span> <span class="n">data_out</span><span class="p">,</span> <span class="n">read_control</span><span class="p">,</span> <span class="n">write_control</span><span class="p">)</span>

    <span class="n">addresses</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">1024</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">)]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="p">),</span> <span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">)]</span>

    <span class="nd">@instance</span>
    <span class="k">def</span> <span class="nf">stimulus</span><span class="p">():</span>

        <span class="c">#write</span>
        <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            
            <span class="n">address</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span> <span class="n">addr</span><span class="p">)[</span><span class="mf">32</span><span class="p">:]</span>
            <span class="n">data_in</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="p">(</span><span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="p">),</span> <span class="nb">max</span><span class="o">=</span><span class="mf">2</span><span class="o">**</span><span class="mf">31</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
            
            <span class="n">write_control</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="n">clk</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>

            <span class="k">print</span> <span class="s">&quot;Write: addr </span><span class="si">%i</span><span class="s"> = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span>
            <span class="n">write_control</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">clk</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span>
        
        <span class="c">#read</span>
        <span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">addresses</span><span class="p">:</span>
            <span class="n">address</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span> <span class="n">addr</span><span class="p">)[</span><span class="mf">32</span><span class="p">:]</span>
            <span class="n">read_control</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="n">clk</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;Read: addr </span><span class="si">%i</span><span class="s"> = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">data_out</span><span class="p">)</span>
            <span class="n">clk</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="n">read_control</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">instances</span><span class="p">()</span>
</pre></div>
</div>
<p>y resultado se lista a continuación:</p>
<div class="highlight-text"><div class="highlight"><pre>Write: addr 533 = -644713194
Write: addr 3 = -688944690
Write: addr 120 = 1362011009
Write: addr 482 = -1948254264
Write: addr 231 = 117441706
Read: addr 533 = -644713194
Read: addr 3 = -688944690
Read: addr 120 = 1362011009
Read: addr 482 = -1948254264
Read: addr 231 = 117441706
</pre></div>
</div>
</div>
<div class="section" id="forwarding-unit">
<h3>Forwarding unit<a class="headerlink" href="#forwarding-unit" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La parelización del pipeline se basa en la superposición de las distintas etapas
de ejecución de cada instrucción. En los casos en que una instrucción depende
del resultado de una precedente se produce un hazard de datos.</p>
<p>Por ejemplo:</p>
<div class="highlight-python"><pre>add $r1, $r2, $r3
sub $r5, $r1, $r4</pre>
</div>
<p>En este caso, la 2º instrucción necesita como operando el resultado en el registro
1 de la operación precedente, que en el flujo normal del pipeline no estará disponible
hasta la etapa de WB (5º ciclo). Sin embargo, en este tipo de dependencias,
una solución el la técnica de <em>forwarding</em> o cortocircuito. Concretamente, el resultado
de la primera operación ya se conoce en la etapa de ejecución, por lo que puede
cortocircuitarse este resultado para que justo un ciclo después (cuando el valor
de la suma <tt class="docutils literal"><span class="pre">$r2</span> <span class="pre">+</span> <span class="pre">$r3</span></tt> esté en la etapa MEM) reemplace al valor de <tt class="docutils literal"><span class="pre">$r1</span></tt>
como primer operando de la ALU.</p>
<p>Este control de dependencia de datos lo realiza la unidad de forwarding.
Detecta un 2 pares de condiciones: que el registro destino (<tt class="docutils literal"><span class="pre">Rd</span></tt>) de una instrucción
en etapa de memoria (el caso del ejemplo) o en WB (que se produce cuando
hay dependencia de datos entre dos instrucciones separadas por una no dependendiente)
es el mismo que alguno de los operandos (<tt class="docutils literal"><span class="pre">Rs</span></tt> o <tt class="docutils literal"><span class="pre">Rt</span></tt>) de la instrucción
en etapa EX.</p>
<p>Para no hacer forwarding innecesariamente (hay instrucciones que no escriben datos)
se controla también si la señal de control <tt class="docutils literal"><span class="pre">RegWrite</span></tt> en etapa MEM está activa.</p>
<div align="center" class="align-center"><object data="_images/aafig-2d8a3dc101b9bbf34b517d6adc9c19212b721a5e.svg" height="294.0" type="image/svg+xml" width="529.2"><embed height="294.0" src="_images/aafig-2d8a3dc101b9bbf34b517d6adc9c19212b721a5e.svg" type="image/svg+xml" width="529.2" /></object>
</div>
<p>Esta unidad produce dos señales de control (<tt class="docutils literal"><span class="pre">ForwardA</span></tt> y <tt class="docutils literal"><span class="pre">ForwardB</span></tt>) de 2 bits
que puede tomar valores 0, 1 o 2 para controlar sendos multiplexores a la entradas
de la ALU. La significación de cada valor se describe en esta tabla:</p>
<img alt="_images/forwarding_table.png" src="_images/forwarding_table.png" style="width: 90%;" />
<p>La implementación de este componente es la siguiente:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">forwarding</span><span class="p">(</span><span class="n">RegWrite_mem</span><span class="p">,</span> <span class="n">Rd_mem</span><span class="p">,</span> <span class="n">Rs_ex</span><span class="p">,</span> <span class="n">Rt_ex</span><span class="p">,</span>     <span class="c">#inputs of EX hazards</span>
                <span class="n">RegWrite_wb</span><span class="p">,</span> <span class="n">Rd_wb</span><span class="p">,</span>   <span class="c">#left inputs of MEM hazards</span>
                <span class="n">ForwardA</span><span class="p">,</span> <span class="n">ForwardB</span>
                <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects and controls forwarding for 2 pairs of data hazard conditions:</span>

<span class="sd">        1a. Rd_mem = Rs_ex</span>
<span class="sd">        1b. Rd_mem = Rt_ex</span>

<span class="sd">        1a. Rd_wb = Rs_ex</span>
<span class="sd">        2b. Rd_wb = Rt_ex</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">hazards_control</span><span class="p">():</span>

        <span class="c">#1a</span>
        <span class="k">if</span> <span class="n">RegWrite_mem</span> <span class="o">==</span> <span class="mf">1</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">!=</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">==</span> <span class="n">Rs_ex</span><span class="p">:</span>
            <span class="n">ForwardA</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">2</span>  <span class="c">#int(&#39;10&#39;, 2)</span>

        <span class="c">#2a</span>
        <span class="k">elif</span> <span class="n">RegWrite_wb</span> <span class="o">==</span> <span class="mf">1</span> <span class="ow">and</span> <span class="n">Rd_wb</span> <span class="o">!=</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">!=</span> <span class="n">Rs_ex</span> <span class="ow">and</span> <span class="n">Rd_wb</span> <span class="o">==</span> <span class="n">Rs_ex</span><span class="p">:</span>
            <span class="n">ForwardA</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> <span class="c">#int(&#39;01&#39;, 2)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ForwardA</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            

        <span class="c">#1b</span>
        <span class="k">if</span> <span class="n">RegWrite_mem</span> <span class="o">==</span> <span class="mf">1</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">!=</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">==</span> <span class="n">Rt_ex</span><span class="p">:</span>
            <span class="n">ForwardB</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">2</span> <span class="c">#int(&#39;10&#39;, 2)</span>

        <span class="c">#2b</span>
        <span class="k">elif</span> <span class="n">RegWrite_wb</span> <span class="o">==</span> <span class="mf">1</span> <span class="ow">and</span> <span class="n">Rd_wb</span> <span class="o">!=</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">!=</span> <span class="n">Rt_ex</span> <span class="ow">and</span> <span class="n">Rd_wb</span> <span class="o">==</span> <span class="n">Rt_ex</span><span class="p">:</span>
            <span class="n">ForwardB</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> <span class="c">#int(&#39;01&#39;, 2)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ForwardB</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>

    <span class="k">return</span> <span class="n">hazards_control</span>
</pre></div>
</div>
<p>En reemplazo de un TestBench se ha realizado una seria de pruebas de unitarias
que prueban distintas combinaciones de la señales de entrada y verifican que
el resultado de la señal de control para cada multiplexor sea correcto.</p>
<p>Esos test se detallan en el código implementado:</p>
<blockquote>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">testBench</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>



    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rs_ex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rt_ex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rd_wb</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">5</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">4</span><span class="p">)</span> <span class="p">]</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span> <span class="p">]</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">2</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span> <span class="p">]</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span> <span class="o">=</span> <span class="n">toVHDL</span><span class="p">(</span><span class="n">forwarding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rs_ex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rt_ex</span><span class="p">,</span>   <span class="c">#inputs of EX hazards</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rd_wb</span><span class="p">,</span>   <span class="c">#left inputs of MEM hazards</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span>
                    <span class="p">)</span>
    

    <span class="k">def</span> <span class="nf">test_not_regwrite_mem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>

        
        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_not_regwrite_wb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">test_1a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> 

            <span class="n">val</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">**</span><span class="mf">5</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rs_ex</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;10&#39;</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
            

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">test_1b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> 

            <span class="n">val</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">**</span><span class="mf">5</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rt_ex</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;10&#39;</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
            

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">test_2a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RegWrite_wb == 1 and Rd_wb != 0 and Rd_mem != Rs_ex and Rd_wb == Rs_ex&quot;&quot;&quot;</span>

        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> 

            <span class="n">val</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">**</span><span class="mf">5</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rs_ex</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="mf">1</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;01&#39;</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
            

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_2b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;elif RegWrite_wb == 1 and Rd_wb != 0 and Rd_mem != Rt_ex and Rd_wb == Rt_ex&quot;&quot;&quot;</span>

        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> 

            <span class="n">val</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">**</span><span class="mf">5</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rt_ex</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="mf">1</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;01&#39;</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
            

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

            
</pre></div>
</div>
</blockquote>
<p>Al ejecutar el módulo Python, el framework para <em>Unittest</em> incorporado de manera
estándar con el lenguaje ejecuta el método <tt class="docutils literal"><span class="pre">setUp</span></tt> previamente
y luego cada uno de las pruebas (métodos de la clase
<tt class="docutils literal"><span class="pre">testBench</span></tt> que comienzan con el prefijo <tt class="docutils literal"><span class="pre">test_</span></tt>) y verifica el resultado
de las aserciones. Por supuesto, en la implemtación todos los test son satisfechos:</p>
<div class="highlight-python"><pre>----------------------------------------------------------------------
Ran 6 tests in 0.362s

OK</pre>
</div>
</div>
<div class="section" id="hazard-detector">
<h3>Hazard detector<a class="headerlink" href="#hazard-detector" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Existe un caso de dependecia de datos que no puede resolverse mediante <em>forwarding</em>.
Es el caso cuando un dato necesario para ejecutar una instrucción depende de la
lectura desde memoria en una instrucción precedente:</p>
<p>Por ejemplo:</p>
<div class="highlight-python"><pre>lw $r1, 5($r1)
add $r2, $r1, $r3</pre>
</div>
<p>En este ejemplo el valor de <tt class="docutils literal"><span class="pre">$r1</span></tt> según la primera instrucción deberá ser
el valor de la posición de memoria <tt class="docutils literal"><span class="pre">$r1</span> <span class="pre">+</span> <span class="pre">5</span></tt>, pero esto no sucederá hasta la etapa
de WriteBack en el 5to ciclo, mientras que dicho dato es necesario en el 4to ciclo
en la etapa de ejecución de la instrucción <tt class="docutils literal"><span class="pre">add</span></tt>.</p>
<p>La solución en este caso es &#8220;pausar&#8221; (<em>stall</em>) el pipeline por un ciclo para permitir
que la lógica de forwarding pueda manejar la dependencia.</p>
<div align="center" class="align-center"><object data="_images/aafig-d943d7da71d656834701e315c3128cc980f97ca7.svg" height="294.0" type="image/svg+xml" width="516.6"><embed height="294.0" src="_images/aafig-d943d7da71d656834701e315c3128cc980f97ca7.svg" type="image/svg+xml" width="516.6" /></object>
</div>
<p>La señal de <em>Stall</em> inhibe el incremento del contrador de programa (PC) y del latch
<tt class="docutils literal"><span class="pre">IF/ID</span></tt>. Además pone a 0 todas las señales de control, de manera que ningún dato
sea grabado (ya sea en el banco de registros o en la memoria de datos).
Esto es, básicamente, instroducir una instrucción <tt class="docutils literal"><span class="pre">nop</span></tt> (<em>no operation</em>) entre
la instrucción de carga y la r-type:</p>
<div class="highlight-python"><pre>lw $r1, 5($r1)
nop
add $r2, $r1, $r3</pre>
</div>
<p>El código de implementación de esta unidad es el siguiente:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">forwarding</span><span class="p">(</span><span class="n">RegWrite_mem</span><span class="p">,</span> <span class="n">Rd_mem</span><span class="p">,</span> <span class="n">Rs_ex</span><span class="p">,</span> <span class="n">Rt_ex</span><span class="p">,</span>     <span class="c">#inputs of EX hazards</span>
                <span class="n">RegWrite_wb</span><span class="p">,</span> <span class="n">Rd_wb</span><span class="p">,</span>   <span class="c">#left inputs of MEM hazards</span>
                <span class="n">ForwardA</span><span class="p">,</span> <span class="n">ForwardB</span>
                <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects and controls forwarding for 2 pairs of data hazard conditions:</span>

<span class="sd">        1a. Rd_mem = Rs_ex</span>
<span class="sd">        1b. Rd_mem = Rt_ex</span>

<span class="sd">        1a. Rd_wb = Rs_ex</span>
<span class="sd">        2b. Rd_wb = Rt_ex</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">hazards_control</span><span class="p">():</span>

        <span class="c">#1a</span>
        <span class="k">if</span> <span class="n">RegWrite_mem</span> <span class="o">==</span> <span class="mf">1</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">!=</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">==</span> <span class="n">Rs_ex</span><span class="p">:</span>
            <span class="n">ForwardA</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">2</span>  <span class="c">#int(&#39;10&#39;, 2)</span>

        <span class="c">#2a</span>
        <span class="k">elif</span> <span class="n">RegWrite_wb</span> <span class="o">==</span> <span class="mf">1</span> <span class="ow">and</span> <span class="n">Rd_wb</span> <span class="o">!=</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">!=</span> <span class="n">Rs_ex</span> <span class="ow">and</span> <span class="n">Rd_wb</span> <span class="o">==</span> <span class="n">Rs_ex</span><span class="p">:</span>
            <span class="n">ForwardA</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> <span class="c">#int(&#39;01&#39;, 2)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ForwardA</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            

        <span class="c">#1b</span>
        <span class="k">if</span> <span class="n">RegWrite_mem</span> <span class="o">==</span> <span class="mf">1</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">!=</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">==</span> <span class="n">Rt_ex</span><span class="p">:</span>
            <span class="n">ForwardB</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">2</span> <span class="c">#int(&#39;10&#39;, 2)</span>

        <span class="c">#2b</span>
        <span class="k">elif</span> <span class="n">RegWrite_wb</span> <span class="o">==</span> <span class="mf">1</span> <span class="ow">and</span> <span class="n">Rd_wb</span> <span class="o">!=</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">Rd_mem</span> <span class="o">!=</span> <span class="n">Rt_ex</span> <span class="ow">and</span> <span class="n">Rd_wb</span> <span class="o">==</span> <span class="n">Rt_ex</span><span class="p">:</span>
            <span class="n">ForwardB</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> <span class="c">#int(&#39;01&#39;, 2)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ForwardB</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>

    <span class="k">return</span> <span class="n">hazards_control</span>
</pre></div>
</div>
<p>Los test unitarios se detallan en el siguiente código:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">testBench</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>



    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rs_ex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rt_ex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rd_wb</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">5</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">4</span><span class="p">)</span> <span class="p">]</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span> <span class="p">]</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">2</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span> <span class="p">]</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span> <span class="o">=</span> <span class="n">toVHDL</span><span class="p">(</span><span class="n">forwarding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rs_ex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rt_ex</span><span class="p">,</span>   <span class="c">#inputs of EX hazards</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rd_wb</span><span class="p">,</span>   <span class="c">#left inputs of MEM hazards</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span>
                    <span class="p">)</span>
    

    <span class="k">def</span> <span class="nf">test_not_regwrite_mem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>

        
        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_not_regwrite_wb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span><span class="p">),</span> <span class="mf">0</span><span class="p">)</span>

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">test_1a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> 

            <span class="n">val</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">**</span><span class="mf">5</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rs_ex</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;10&#39;</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
            

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">test_1b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> 

            <span class="n">val</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">**</span><span class="mf">5</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rt_ex</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;10&#39;</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
            

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">test_2a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RegWrite_wb == 1 and Rd_wb != 0 and Rd_mem != Rs_ex and Rd_wb == Rs_ex&quot;&quot;&quot;</span>

        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> 

            <span class="n">val</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">**</span><span class="mf">5</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rs_ex</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="mf">1</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardA</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;01&#39;</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
            

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_2b</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;elif RegWrite_wb == 1 and Rd_wb != 0 and Rd_mem != Rt_ex and Rd_wb == Rt_ex&quot;&quot;&quot;</span>

        <span class="nd">@instance</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">RegWrite_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span> 

            <span class="n">val</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="o">**</span><span class="mf">5</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_wb</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Rt_ex</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Rd_mem</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="mf">1</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ForwardB</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="s">&#39;01&#39;</span><span class="p">,</span><span class="mf">2</span><span class="p">))</span>
            

        <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forwarding_</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

            
</pre></div>
</div>
</div>
<div class="section" id="latchs">
<h3>Latchs<a class="headerlink" href="#latchs" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un latch es dispositivo secuencial que refresca los puertos de salida con los valores
de los puertos de entrada correspondientes ante el flanco (positivo) de una señal
de clock o trigger. Además puede incorporar una señal de Reset o Flush, que
pone todos los puertos de salida a 0 independientemente del valor de las entradas,
y también una señal de <em>Stall</em> o inhibidor, que mantiene el valor previo de los
puertos de salida en caso de estar a 1.</p>
<div align="center" class="align-center"><object data="_images/aafig-d64afd6a0cd9a1f77112641bde5fca72bf8dee5a.svg" height="189.0" type="image/svg+xml" width="466.2"><embed height="189.0" src="_images/aafig-d64afd6a0cd9a1f77112641bde5fca72bf8dee5a.svg" type="image/svg+xml" width="466.2" /></object>
</div>
<p>Los <em>latchs</em> se encargan de retener y estabilizar los datos entre las etapas.
manteniendo la integridad de las señales.
Son los componentes claves para permitir la paralelización de la etapas.</p>
<p>Como nomenclatura, cuando se menciona el componente <tt class="docutils literal"><span class="pre">IF/ID</span></tt> se refiere al
latch entre la etada <em>Intruction Fetch (IF)</em> e <em>Intruction Decoder (ID)</em>.</p>
<p>Todos los componentes de este tipo son análogos, por lo que sólo se mostrará en
este reporte el código de  <tt class="docutils literal"><span class="pre">IF/ID</span></tt> y su correspondiente TestBench.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">latch_if_id</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">instruction_in</span><span class="p">,</span> <span class="n">pc_adder_in</span><span class="p">,</span> <span class="n">instruction_out</span><span class="p">,</span> <span class="n">pc_adder_out</span><span class="p">,</span> <span class="n">stall</span><span class="o">=</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Latch to control state between Instruction Fetch and Instruction Decoder</span>

<span class="sd">    clk -- trigger</span>
<span class="sd">    rst -- reset </span>
<span class="sd">    instruction_in  -- 32 bits signal input</span>
<span class="sd">    pc_adder_in -- 32 bits signal input</span>
<span class="sd">    instruction_out  -- 32 bits signal output for instruction decoder</span>
<span class="sd">    pc_adder_out -- 32 bits signal output for pc_add</span>

<span class="sd">    stall -- inhibit the count increment</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">,</span> <span class="n">rst</span><span class="o">.</span><span class="n">posedge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">latch</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">rst</span> <span class="o">==</span> <span class="mf">1</span><span class="p">:</span>
            <span class="n">instruction_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">pc_adder_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stall</span><span class="p">:</span>
                <span class="n">instruction_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">instruction_in</span>
                <span class="n">pc_adder_out</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pc_adder_in</span>


    <span class="k">return</span> <span class="n">latch</span>
</pre></div>
</div>
<p>El testbench genera señales de Clock, Reset y Stall aleatoriamente (con cierta
probabilidad).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">testBench</span><span class="p">():</span>

    <span class="n">i_in</span><span class="p">,</span> <span class="n">pc_in</span><span class="p">,</span> <span class="n">i_out</span><span class="p">,</span> <span class="n">pc_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">32</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">4</span><span class="p">)]</span>

    <span class="n">clk</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">stall</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">3</span><span class="p">)]</span>
    
   
    <span class="n">latch_inst</span> <span class="o">=</span> <span class="n">toVHDL</span><span class="p">(</span><span class="n">latch_if_id</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">i_in</span><span class="p">,</span> <span class="n">pc_in</span><span class="p">,</span> <span class="n">i_out</span><span class="p">,</span> <span class="n">pc_out</span><span class="p">,</span> <span class="n">stall</span><span class="p">)</span>

    <span class="nd">@instance</span>
    <span class="k">def</span> <span class="nf">stimulus</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">10</span><span class="p">):</span>
            <span class="n">i_in</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">pc_in</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">[</span><span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">255</span><span class="p">))[</span><span class="mf">32</span><span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">2</span><span class="p">)]</span>
            
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.10</span><span class="p">:</span>
                <span class="n">clk</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.75</span><span class="p">:</span>
                <span class="n">rst</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="n">stall</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>

            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;Inputs: </span><span class="si">%i</span><span class="s"> </span><span class="si">%i</span><span class="s"> | clk: </span><span class="si">%i</span><span class="s">  rst: </span><span class="si">%i</span><span class="s"> stall:</span><span class="si">%i</span><span class="s"> | Output: </span><span class="si">%i</span><span class="s"> </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i_in</span><span class="p">,</span> <span class="n">pc_in</span><span class="p">,</span> <span class="n">clk</span><span class="p">,</span> <span class="n">rst</span><span class="p">,</span> <span class="n">stall</span><span class="p">,</span> <span class="n">i_out</span><span class="p">,</span> <span class="n">pc_out</span> <span class="p">)</span>
            <span class="n">clk</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">rst</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="n">stall</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">instances</span><span class="p">()</span>
</pre></div>
</div>
<p>Un resultado es el siguiente:</p>
<div class="highlight-text"><div class="highlight"><pre>Inputs: 216 139 | clk: 1  rst: 0 stall:0 | Output: 216 139
Inputs: 21 31 | clk: 0  rst: 0 stall:0 | Output: 216 139
Inputs: 171 231 | clk: 1  rst: 0 stall:1 | Output: 216 139
Inputs: 253 238 | clk: 1  rst: 1 stall:0 | Output: 0 0
Inputs: 17 124 | clk: 1  rst: 1 stall:1 | Output: 0 0
Inputs: 132 187 | clk: 1  rst: 0 stall:1 | Output: 0 0
Inputs: 183 27 | clk: 1  rst: 0 stall:1 | Output: 0 0
Inputs: 69 114 | clk: 1  rst: 1 stall:0 | Output: 0 0
Inputs: 104 35 | clk: 1  rst: 1 stall:1 | Output: 0 0
Inputs: 159 199 | clk: 1  rst: 0 stall:0 | Output: 159 199
</pre></div>
</div>
</div>
</div>
<div class="section" id="datapath">
<h2>Datapath<a class="headerlink" href="#datapath" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El datapath es la versión sin pipeline del procesador. Responde al siguiente
diseño:</p>
<blockquote>
<img alt="_images/datapath.png" src="_images/datapath.png" style="width: 100%;" />
</blockquote>
<p>La característica de esta implementación es que las instrucciones no se
solapan, por lo que el proceso es ejecutar una instrucción desde el inicio
hasta el fin (4 o 5 ciclos) para recién comenzar a ejecutar la siguiente
instrucción. Por ello es que la frecuencia de incremento del PC es 4 o 5 veces
mayor que la del clock general del sistema</p>
<p>En el archivo <em>datapath.py</em> puede encontrarse su implementación.</p>
</div>
<div class="section" id="pipeline">
<h2>Pipeline<a class="headerlink" href="#pipeline" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Una versión preliminar del procesador con pipeline se encuentra en el archivo
<em>pipeline.py</em> . Esta versión implementa la paralelización mediante el uso
de los latchs pero no gestiona el control de hazards.</p>
<p>Responde al siguiente diseño <a class="footnote-reference" href="#id7" id="id6">[2]</a>:</p>
<blockquote>
<img alt="_images/pipeline.png" src="_images/pipeline.png" style="width: 100%;" />
</blockquote>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td>El diagrama ha sido levemente simplificado y por una cuestión de
claridad se suprimen los nombres de algunas señales</td></tr>
</tbody>
</table>
</div>
<div class="section" id="dlx">
<h2>DLX<a class="headerlink" href="#dlx" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Es el procesador completo incorpora la unidad de forwarding y la detección de
hazards.</p>
<p>El conexionado de la unidad de forwarding se ilustra en el siguiente gráfico:</p>
<blockquote>
<img alt="_images/forwarding_conections.png" src="_images/forwarding_conections.png" style="width: 100%;" />
</blockquote>
<p>Una representación general <a class="footnote-reference" href="#id9" id="id8">[3]</a> del DLX se muestra en la siguiente figura:</p>
<blockquote>
<img alt="_images/dlx_simplified.png" src="_images/dlx_simplified.png" style="width: 100%;" />
</blockquote>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[3]</a></td><td>La etapadas ID y EX están simplificadas (extensor de signo y lógica
de control de branch no se muestran).</td></tr>
</tbody>
</table>
<p>El archivo de código fuente <em>dlx.py</em> contiene la implementación, a nivel
estructural, del procesador completo.</p>
<p>Como se explica en la descripción de cada componente, la <em>unidad de
forwarding</em> implementa la lógica para hazard de datos entre instrucciones r-types de 1 o
2 saltos, mientras que el <em>hazard detector</em> aplica la técnica de la
inserción de <em>stalls</em> aplicables a los hazard de datos del tipo  <em>Read after
Load</em> y los hazard de control o branch.</p>
<div class="section" id="ejemplo-de-forwarding">
<h3>Ejemplo de Forwarding<a class="headerlink" href="#ejemplo-de-forwarding" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para ejemplificar el funcionamiento del forwarding se ejecuta en el DLX el
siguente programa :</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">ensamblador</th>
<th class="head">instrucciones compiladas</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>add $r1, $r2, $r3</td>
<td>000000 00010 00011 00001 00000 100000</td>
</tr>
<tr><td>sub $r5, $r1, $r4</td>
<td>000000 00001 00100 00101 00000 100010</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Dada la inicialización del banco de registros al valor <tt class="docutils literal"><span class="pre">i+1</span></tt> para cada
registro i, las operaciones precedentes equivalen al siguiente pseudocódigo:</p>
<div class="highlight-python"><pre>==============  ============  ======================
 pseudocódigo    operadores    resultado esperado
==============  ============  ======================
 r1 = r2 + r3    r1 = 3 + 4    r1 = 7
 r5 = r1 - r4    r5 = 7 - 5    r5 = 2
==============  ============  ======================</pre>
</div>
<p>En el archivo <em>dump_raw_forw.txt</em> se encuentra la salida estándar completa
para una simulación durante 6 ciclos de reloj de ejecución de este programa.</p>
<p>Las claves de la correción en la ejecución son:</p>
<ul>
<li><p class="first">El forwarding se produce en el 4to ciclo:</p>
<div class="highlight-python"><pre>ForwardA 2</pre>
</div>
</li>
<li><p class="first">El multiplexor intervenido es el A (primer operando de la ALU) debido a que
el destino (<tt class="docutils literal"><span class="pre">Rd</span></tt>) de la 1º instrucción es el mismo que el primer
operador (<tt class="docutils literal"><span class="pre">Rs</span></tt>) de la segunda.</p>
</li>
<li><p class="first">En el 4to ciclo puede observarse que si bien <tt class="docutils literal"><span class="pre">Data2</span></tt> (el verdadero valor de
<tt class="docutils literal"><span class="pre">r1</span></tt> en ese instante) es <tt class="docutils literal"><span class="pre">2</span></tt>, debido al forwarding el operando que ingresa a
la ALU es <tt class="docutils literal"><span class="pre">7</span></tt>, que efectivamente el resultado de la operación ALU previa:</p>
<div class="highlight-python"><pre>AluResult_mem 7</pre>
</div>
</li>
<li><p class="first">Al final, puede observarse que el estado del los primeros bancos de registros en el
6º ciclo es:</p>
<div class="highlight-python"><pre>reg: [1, 7, 3, 4, 5, 2]</pre>
</div>
<p>Lo cual es correcto.</p>
</li>
</ul>
</div>
<div class="section" id="ejemplo-de-hazard-read-after-load">
<h3>Ejemplo de hazard <em>Read after Load</em><a class="headerlink" href="#ejemplo-de-hazard-read-after-load" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El programa que se simula en este caso es el siguiente:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">ensamblador</th>
<th class="head">instrucciones compiladas</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>lw $r1, 5($r1)</td>
<td>100011 00001 00001  0000000000000101</td>
</tr>
<tr><td>add $r2, $r1, $r3</td>
<td>000000 00001 00011 00010 00000 100000</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Como antes, los registros se inicializan al valor <tt class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></tt>, y la posición
de memoria 7 se inicializa a <tt class="docutils literal"><span class="pre">51</span></tt> (valor arbitrario)</p>
<p>La significación y los resultados esperados se resumen en la siguiente tabla:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="25%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">pseudocódigo</th>
<th class="head">operadores</th>
<th class="head">resultado esperado</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>r1 = Mem[r1 + 5]</td>
<td>r1 = Mem[7]</td>
<td>r1 = 51</td>
</tr>
<tr><td>r2 = r1 + r3</td>
<td>r2 = 51 + 4</td>
<td>r2 = 55</td>
</tr>
</tbody>
</table>
</blockquote>
<p>En el archivo <em>dump_raw_stall.txt</em> se encuentra la salida estándar completa
para una simulación durante 7 ciclos de reloj de ejecución de este programa.</p>
<p>La claves de interpretación se resumen a continuación:</p>
<ul>
<li><p class="first">En el 3º ciclo, cuando la segunda instrucción llega a la etapa ID, se
detecta el hazard y se produce el stall. En la línea 110 del dump se
observa:</p>
<div class="highlight-python"><pre>Stall --&gt; 1</pre>
</div>
</li>
<li><p class="first">Esto repercute en que todas las señales de control a partir de ese ciclo se
ponen a 0:</p>
<div class="highlight-python"><pre>RegDst 0  ALUop 00  ALUSrc 0 | Branch 0  MemR 0  MemW 0 |  RegW 0 Mem2Reg 0</pre>
</div>
</li>
<li><p class="first">Y que durante el siguiente ciclo (el 4to), la instrucción en IF es
la misma (2297888 en decimal)</p>
</li>
<li><p class="first">En el 5to ciclo la unidad de forwarding ya puede cortocircuitar el
dato solicitado a memoria (<tt class="docutils literal"><span class="pre">ForwardA</span> <span class="pre">1</span></tt>) haciendo que el operador para la
etapa de ejecución sea <tt class="docutils literal"><span class="pre">51</span></tt> en vez de <tt class="docutils literal"><span class="pre">2</span></tt> que es el valor de <tt class="docutils literal"><span class="pre">Data1</span></tt>
en ese instante.</p>
</li>
<li><p class="first">Debido a este <em>stall</em> la cantidad de ciclos usados para ejecutar el
programa completo es 6 en vez de 5 como en el ejemplo de hazard de datos
anterior, donde el dato podía encontrarse en una etapa precedente y
resolverse directamente por forwarding</p>
</li>
<li><p class="first">Al final de la simulación puede observarse que el estado del banco de
registros es el siguiente:</p>
<div class="highlight-python"><pre>reg: [1, 51, 55, 4, 5, 6]</pre>
</div>
<p>Lo cual es correcto.</p>
</li>
</ul>
</div>
<div class="section" id="ejemplo-de-hazard-de-control">
<h3>Ejemplo de hazard de control<a class="headerlink" href="#ejemplo-de-hazard-de-control" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los hazard de control o branch se producen cuando hay un salto condicional.
Para saber si el salto debe realizarse o se debe seguir procesando
linealmente es necesario conocer el resultado de la operación de la condición
(en la implementación del DLX la única instrucción de este tipo es <tt class="docutils literal"><span class="pre">beq</span></tt>,
<em>branch on equal</em>,  que realiza una resta con lo operando de la ALU y verifica
el flag <tt class="docutils literal"><span class="pre">Zero</span></tt> ).</p>
<p>Dado que para realizar esta operación es necesario que la instrucción llegue
a la etapa de ejecución (3 ciclos) debe definirse una estrategia que permita
aprovechar el procesamiento de la etapas previas a EX para procesar otras
instrucciones.</p>
<p>La estrategia más simple, que es la implementada en este proyecto, es definir
que <em>a priori</em> el resultado de la condicion siempre es falso, es decir que el
<em>branch</em> no se toma. Si al obtener el resultado verificamos que la decisión
anticipada fue correcta, se habrán ganado dos ciclos de reloj  (las
intrucciones que se encuentran en IF e ID). En caso de que la decisión haya
sido incorrecta hay que descartar las dos instrucciones que ingresaron al
pipeline incorrectamente.</p>
<p>Esto se realiza sin hardware adicional, ya que el branch se detecta realmente
en la etapa MEM mediante la señal PCSrc (que controla un multiplexor cuyas
entradas son la <tt class="docutils literal"><span class="pre">PC+1</span></tt> o la dirección efectiva calculada <tt class="docutils literal"><span class="pre">PC+salto</span></tt>. En
caso de producirse un salto, esa misma señal puede utilizarse para vaciar
(<em>flush</em>) los latchs <tt class="docutils literal"><span class="pre">IF/ID</span></tt> e <tt class="docutils literal"><span class="pre">ID/EX</span></tt> para descartar las dos
instrucciones erróneas, y poner todas las señales de
control a 0. Las instrucciones previas al salto que todavía se encuentran en
el pipeline finalizan su ejecución normal.</p>
<p>El programa que se simula en este caso es el siguiente:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">ensamblador</th>
<th class="head">instrucciones compiladas</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>add $r0, $r1, $r2</td>
<td>000000 00001 00010 00000 00000 100000</td>
</tr>
<tr><td>beq r4, r4, -1</td>
<td>000100 00100 00100  1111111111111111</td>
</tr>
<tr><td>add $r1, $r2, $r3</td>
<td>000000 00010 00011 00001 00000 100000</td>
</tr>
<tr><td>sub $r5, $r1, $r4</td>
<td>000000 00001 00100 00101 00000 100010</td>
</tr>
</tbody>
</table>
</blockquote>
<p>La significación y los resultados esperados se resumen en la siguiente tabla:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="26%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">pseudocódigo</th>
<th class="head">operadores</th>
<th class="head">resultado esperado</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>r0 = r1 + r2</td>
<td>r0 = 2 + 3</td>
<td>r0 = 5</td>
</tr>
<tr><td>if(r4 == r4) go2 $-1</td>
<td>5 == 5 =&gt; True</td>
<td>next_ip = 0</td>
</tr>
<tr><td>r1 = r2 + r3</td>
<td>r1 = 3 + 4</td>
<td>instrucción descartada</td>
</tr>
<tr><td>r5 = r1 - r4</td>
<td>&nbsp;</td>
<td>instrucción descartada</td>
</tr>
</tbody>
</table>
</blockquote>
<p>En el archivo <em>dump_control.txt</em> se encuentra la salida estándar completa
para una simulación durante 10 ciclos de reloj de ejecución de este programa.</p>
<p>Las claves para interpretar la corrección de la ejecución se detallan a
continuación:</p>
<ul>
<li><p class="first">En el 4to ciclo en EX se realiza el cálculo de la condición (la resta <tt class="docutils literal"><span class="pre">5</span> <span class="pre">-</span>
<span class="pre">5</span></tt>). El resultado es <tt class="docutils literal"><span class="pre">0</span></tt> y la señal <tt class="docutils literal"><span class="pre">Zero_ex</span></tt> se pone a <tt class="docutils literal"><span class="pre">1</span></tt>.
Significa que la condición es verdadera (obviamente, ya que se está comparando un
registro con sí mismo) y por lo tanto el salto se realizará</p>
</li>
<li><p class="first">En ese mismo ciclo puede observarse que las dos etapas previas (<tt class="docutils literal"><span class="pre">IF</span></tt>
e <tt class="docutils literal"><span class="pre">ID</span></tt>) están procesando las dos instrucciones subsecuentes (<tt class="docutils literal"><span class="pre">add</span></tt> en
<tt class="docutils literal"><span class="pre">ID</span></tt> y <tt class="docutils literal"><span class="pre">sub</span></tt> en <tt class="docutils literal"><span class="pre">IF</span></tt>.</p>
</li>
<li><p class="first">En el 5to ciclo las señales de detección de zero y la señal Branch
generada en la unidad de control (ambas en <tt class="docutils literal"><span class="pre">1</span></tt>) se encuentran en la etapa
<tt class="docutils literal"><span class="pre">MEM</span></tt> y producen (mediante una compuerta AND) la señal <tt class="docutils literal"><span class="pre">PCSrc_mem</span></tt> a <tt class="docutils literal"><span class="pre">1</span></tt>. Esta
señal es equivalente a una señal de <tt class="docutils literal"><span class="pre">Flush</span></tt>.</p>
</li>
<li><p class="first">Esa señal <tt class="docutils literal"><span class="pre">Flush</span></tt> vacía los latchs <tt class="docutils literal"><span class="pre">IF/ID</span></tt> e <tt class="docutils literal"><span class="pre">ID/EX</span></tt> por lo que las
señales y buses son todos 0 en el 5to ciclo.</p>
</li>
<li><p class="first">También se observa que el nuevo <tt class="docutils literal"><span class="pre">Ip</span></tt> es <tt class="docutils literal"><span class="pre">0</span></tt>, que se corresponde al
salto de una instrucción hacia atrás (<tt class="docutils literal"><span class="pre">-1</span></tt>) respecto de la posición de
la instrucción <tt class="docutils literal"><span class="pre">beq</span></tt> que implica volver a la primera instrucción del
programa</p>
</li>
<li><p class="first">En la etapa de WB del 5to ciclo la instrucción previa al salto se completa (no ha sido
afectada) y puede observarse que el estado de los registros es el
siguiente:</p>
<div class="highlight-python"><pre>reg: [5, 2, 3, 4, 5, 6]</pre>
</div>
<p>Lo cual es correcto.</p>
</li>
<li><p class="first">En el ciclo 9 la instrucción de salto vuelve a generar la señal <tt class="docutils literal"><span class="pre">PCSrc_mem</span></tt>
a <tt class="docutils literal"><span class="pre">1</span></tt> y el programa salta al inicio nuevamente. El programa de ejemplo es
bucle infinito.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="conclusiones">
<h1>Conclusiones<a class="headerlink" href="#conclusiones" title="Enlazar permanentemente con este título">¶</a></h1>
<p>La codificación de un procesador RISC sencillo pero completo ha permitido
consolidar conceptos teóricos como los diferentes tipos de hazards
(estructurales, de datos y de control) y las distintas estrategias para
solucionarlos.</p>
<p>La paralelización a nivel de instrucciones y sus ventajas en el mejoramiento
del CPI para un conjunto de instrucciones se pudo medir comparando los ciclos
consumidos por la implementación <a class="reference internal" href="#datapath">Datapath</a> y por la versión completa <a class="reference internal" href="#dlx">DLX</a> -</p>
<p>La posibilidad de &#8220;programar hardware&#8221; en un lenguaje de alto nivel,
valiéndose de técnicas como pruebas unitarias y la simulación permite unir
disciplinas a priori divergentes que confluyen en este trabajo.</p>
<p>El hecho de haber utilizado el lenguaje de programación Python y el paquete
MyHDL para la codificación de este proyecto permitió una alta productividad
y un tiempo de desarrollo mucho más veloz que con lenguajes de descripción
de hardware tradicionales como VHDL o Verilog. Esto se debió en parte, por
supuesto, a que poseía conocimientos previos de python y no de los otros
lenguajes.</p>
<p>Además, el hecho de que el código MyHDL sea convertible a VHDL o Verilog
permite hacer una comparación sintáctica de códigos que semánticamente
dicen lo mismo.</p>
<p>Quedó fuera de la experimentación realizada en este trabajo pero la
posiblidad de MyHDL de <em>cosimular</em> los TestBenchs codificados en Python con
las versiones de componentes en Verilog sintetizable es una tarea interesante
que demostraría contundemente las ventajas de la descripción de hardware a
&#8220;alto nivel*.</p>
<table class="docutils citation" frame="void" id="myhdldoc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[MyHDLDoc]</a></td><td>: <em>MyHDL Documentation</em>, Jan Decaluwe, 2009, <a class="reference external" href="http://myhdl.org">http://myhdl.org</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="whymyhdl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[WhyMyHDL]</a></td><td>: <em>Why MyHDL?</em>, Jan Decaluwe, 2009, <a class="reference external" href="http://www.myhdl.org/doku.php/why">http://www.myhdl.org/doku.php/why</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="patterson-hennessy2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Patterson-Hennessy2005]</a></td><td>: <em>Computer Organization and Design, 3th
edition</em>, David Patterson and John
Hennessy, Morgan Kaufmman Publishers,
CA, 2005</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Contenidos</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introducción</a></li>
<li><a class="reference internal" href="#lenguaje-de-implementaci-n">Lenguaje de implementación</a></li>
<li><a class="reference internal" href="#arquitectura">Arquitectura</a><ul>
<li><a class="reference internal" href="#segmentaci-n">Segmentación</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementaci-n">Implementación</a><ul>
<li><a class="reference internal" href="#convenciones-de-c-dificaci-n">Convenciones de códificación</a></li>
<li><a class="reference internal" href="#componentes">Componentes</a><ul>
<li><a class="reference internal" href="#program-counter">Program Counter</a></li>
<li><a class="reference internal" href="#instruction-memory">Instruction Memory</a></li>
<li><a class="reference internal" href="#instruction-decoder">Instruction Decoder</a></li>
<li><a class="reference internal" href="#unidad-de-control">Unidad de control</a></li>
<li><a class="reference internal" href="#multiplexores">Multiplexores</a></li>
<li><a class="reference internal" href="#banco-de-registros">Banco de Registros</a></li>
<li><a class="reference internal" href="#alu">ALU</a></li>
<li><a class="reference internal" href="#alu-control">ALU Control</a></li>
<li><a class="reference internal" href="#sign-extender">Sign Extender</a></li>
<li><a class="reference internal" href="#data-memory">Data Memory</a></li>
<li><a class="reference internal" href="#forwarding-unit">Forwarding unit</a></li>
<li><a class="reference internal" href="#hazard-detector">Hazard detector</a></li>
<li><a class="reference internal" href="#latchs">Latchs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#datapath">Datapath</a></li>
<li><a class="reference internal" href="#pipeline">Pipeline</a></li>
<li><a class="reference internal" href="#dlx">DLX</a><ul>
<li><a class="reference internal" href="#ejemplo-de-forwarding">Ejemplo de Forwarding</a></li>
<li><a class="reference internal" href="#ejemplo-de-hazard-read-after-load">Ejemplo de hazard <em>Read after Load</em></a></li>
<li><a class="reference internal" href="#ejemplo-de-hazard-de-control">Ejemplo de hazard de control</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#conclusiones">Conclusiones</a></li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="index.html"
                        title="Capítulo anterior">Implementación de un procesador DLX</a></p>
  <h3>Esta página</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/report.txt"
           rel="nofollow">Enseñar el código</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Búsqueda rápida</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Introduzca los términos de búsqueda o un módulo, clase o nombre de función.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="index.html" title="Implementación de un procesador DLX"
             >anterior</a> |</li>
        <li><a href="index.html">Implementación de un procesador DLX v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Martín Gaitán.
      Creado con <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.5.
    </div>
  </body>
</html>