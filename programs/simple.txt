#see page 77.                           # meaning               |   ASM                | expected

000000 00010 00011 00001 00000 100000   # r1 = r2 + r3  | add $r1, $r2, $r3  | r1 = 5 
000000 00001 00100 00101 00000 100010   # r5 = r1 - r4  | sub $r5, $r1, $r4  | r5 = 1
#000000 00000 00000 00000 00000 000000   #
000000 00001 00010 00011 00000 100000   # r3 = r1 + r2  | add $r3, $r1, $r2  | r3 = 7



#basic arithmetic  with RAW data hazard. (to test forwawding)  OK.
#000000 00010 00011 00001 00000 100000   # r1 = r2 + r3         | add $r1, $r2, $r3     | r1 = 5 
#000000 00001 00100 00101 00000 100010   # r5 = r1 - r4         | sub $r5, $r1, $r4     | r5 = 1
#
##read following load (to test hazard detector/stalls) . OK.
#100011 00001 00001  0000000000000101    # r1 = Mem[r1 + 5]     | lw $r1, 5($r1)        | r1 = 12




#100011 00001 00001  0000000000000101    # r1 = Mem[r1 + 5]     | lw $r1, 5($r1)        | r1 = 12
#000000 00001 00011 00001 00000 100000   # r1 = r2 + r3         | add $r1, $r1, $r3     | r1 = 5 


#000000 00010 00011 00001 00000 100000   # r1 = r2 + r3         | add $r1, $r2, $r3     | r1 = 5 
#101011 00001 00001  0000000000000101    # r1 = Mem[r1 + 5]     | sw $r1, 5($r1)        | Mem[17] = 12

#000000 00001 00110 00001 00000 100000   # r2 = r1 + r3         | add $r1, $r1, $r6     | r2 = 54
#000000 00000 00000 00000 00000 000000 #

#101011 00001 00010  0000000000000101    # r1 = Mem[r1 + 5]     | sw $r2, 5($r1)        | Mem[17] = 12



#100011 00001 00101  0000000000000101    # r1 = Mem[r1 + 5]     | lw $r5, 5($r1)        | r5 = 12
000000 00000 00000 00000 00000 000000 #
000000 00000 00000 00000 00000 000000 #
000000 00000 00000 00000 00000 000000 #
000000 00000 00000 00000 00000 000000 #
# branch (with control hazard). Ok
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000000 00001 00010 00011 00000 100000   # r3 = r1 + r2          | add $r3, $r1, $r2    | r3 = 59   (doesn't care really)
#000100 00100 00100  1111111111111111    # if(r4 == r4) go2 $-1  | beq r4, r4, -1       | next_ip = 0
#000000 00010 00011 00001 00000 100000   # r1 = r2 + r3          | add $r1, $r2, $r3     | instruction discarted
#000000 00001 00100 00101 00000 100010   # r5 = r1 - r4          | sub $r5, $r1, $r4     | instruction discarted

#load and store. OK
#101011 00001 00010  0000000000000101    # Mem[r1 + 5] = r2     | sw $r2, 5($r1)        | mem[7] = 3
#100011 00001 00000  0000000000000101    # r0 = Mem[r1 + 5]     | lw $r0, 5($r1)        | r0 = 3

#beq OK next_ip but fails when copy that to ip
#000000 00001 00010 00000 00000 100000   # r0 = r1 + r2          | add $r0, $r1, $r2    | r0 = 5 
#000100 00000 00100  1111111111111110    # if(r0 == r4) go2 $-2  | beq r0, r4, -2       | next_ip = 0

